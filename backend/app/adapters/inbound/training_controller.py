"""
FIA v3.0 - Training Controller
FastAPI routes for training management
"""

from fastapi import APIRouter, Depends, UploadFile, File, Form, HTTPException, status
from fastapi.responses import FileResponse, StreamingResponse
from sqlalchemy.ext.asyncio import AsyncSession
from uuid import UUID
from typing import List, Optional
import io
import logging
from pathlib import Path
from datetime import datetime

from app.infrastructure.database import get_database_session
from app.infrastructure.auth import get_current_trainer
from app.domain.entities.trainer import Trainer
from app.domain.entities.training import Training, FileType
from app.domain.schemas.training import TrainingUpload, TrainingResponse, TrainingListResponse
from app.domain.services.file_storage_service import FileStorageService
from app.domain.services.ai_training_generation_service import AITrainingGenerationService, AITrainingGenerationError
from app.adapters.repositories.training_repository import TrainingRepository
from app.utils.file_validation import validate_training_file, get_file_type_from_extension, FileValidationError

# Configure logging
logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api/trainings", tags=["trainings"])


@router.post("/", response_model=TrainingResponse, status_code=status.HTTP_201_CREATED)
async def create_training(
    name: str = Form(..., min_length=1, max_length=200),
    description: Optional[str] = Form(None, max_length=1000),
    is_ai_generated: bool = Form(False, description="Whether this training is generated by AI"),
    file: Optional[UploadFile] = File(None, description="Training material (PDF, PPT, PPTX)"),
    current_trainer: Trainer = Depends(get_current_trainer),
    db: AsyncSession = Depends(get_database_session)
):
    """
    Create new training with file upload or AI generation
    
    Supports multipart/form-data with:
    - name: Training name (required)
    - description: Training description (required for AI trainings)
    - is_ai_generated: Whether this is an AI-generated training (default: false)
    - file: Training material file (required for non-AI trainings)
    """
    
    try:
        # Validate training type and requirements
        if not is_ai_generated:
            # Non-AI trainings require file
            if not file or not file.filename:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="File is required for non-AI trainings"
                )
            
            # Validate uploaded file
            file_extension, mime_type = await validate_training_file(file)
            file_type_str = get_file_type_from_extension(file_extension)
            file_type = FileType(file_type_str)
        else:
            # AI trainings require description
            if not description or not description.strip():
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="Description is required for AI-generated trainings"
                )
            
            # For AI trainings, we'll generate a markdown file
            file_type = FileType.MARKDOWN
            mime_type = "text/markdown"
        
        # Initialize services
        file_storage = FileStorageService()
        training_repo = TrainingRepository(db)
        ai_generation_service = AITrainingGenerationService()
        
        # Create training entity
        temp_training = Training(
            trainer_id=current_trainer.id,
            name=name.strip(),
            description=description.strip() if description else None,
            is_ai_generated=is_ai_generated
        )
        
        try:
            if not is_ai_generated:
                # Handle file upload for traditional trainings
                file_content = io.BytesIO(await file.read())
                
                # Store file using the training ID
                file_path, file_size = await file_storage.store_training_file(
                    trainer_id=current_trainer.id,
                    training_id=temp_training.id,
                    file_content=file_content,
                    original_filename=file.filename,
                    mime_type=mime_type
                )
                
                # Update training with file information
                temp_training.file_path = file_path
                temp_training.file_name = file.filename
                temp_training.file_type = file_type
                temp_training.file_size = file_size
                temp_training.mime_type = mime_type
            else:
                # Generate AI training content
                logger.info(f"ü§ñ AI_TRAINING [GENERATION] Starting AI content generation for '{name}'")
                
                try:
                    # Generate training content using AI service
                    ai_content = await ai_generation_service.generate_training_content(
                        name=name,
                        description=description
                    )
                    
                    logger.info(f"‚úÖ AI_TRAINING [GENERATION] AI content generated - {len(ai_content)} characters")
                    
                    # Convert to file content
                    file_content = io.BytesIO(ai_content.encode('utf-8'))
                    generated_filename = f"{name.replace(' ', '_').lower()}_ai_generated.md"
                    
                    # Store AI-generated file
                    file_path, file_size = await file_storage.store_training_file(
                        trainer_id=current_trainer.id,
                        training_id=temp_training.id,
                        file_content=file_content,
                        original_filename=generated_filename,
                        mime_type=mime_type
                    )
                    
                    logger.info(f"‚úÖ AI_TRAINING [STORAGE] AI content stored - {file_size} bytes")
                    
                except AITrainingGenerationError as ai_error:
                    logger.error(f"‚ùå AI_TRAINING [ERROR] AI generation failed: {str(ai_error)}")
                    
                    # Create fallback content for graceful degradation
                    fallback_content = f"""# {name}

## Formation g√©n√©r√©e par IA - Indisponible temporairement

**Description :** {description}

---

‚ö†Ô∏è **Service temporairement indisponible**

Le service de g√©n√©ration automatique de contenu de formation n'est pas disponible actuellement. 

**Solutions alternatives :**
1. Contactez votre formateur pour obtenir le mat√©riel de formation
2. R√©essayez plus tard lorsque le service sera r√©tabli
3. Cr√©ez une nouvelle formation avec un fichier PDF/PowerPoint

---

*Formation cr√©√©e le {datetime.now().strftime('%d/%m/%Y √† %H:%M')}*
*Service FIA v3.0 - Formation IA Adaptive*
"""
                    
                    file_content = io.BytesIO(fallback_content.encode('utf-8'))
                    generated_filename = f"{name.replace(' ', '_').lower()}_fallback.md"
                    
                    # Store fallback file
                    file_path, file_size = await file_storage.store_training_file(
                        trainer_id=current_trainer.id,
                        training_id=temp_training.id,
                        file_content=file_content,
                        original_filename=generated_filename,
                        mime_type=mime_type
                    )
                    
                    logger.info(f"üìÑ AI_TRAINING [FALLBACK] Fallback content stored - {file_size} bytes")
                
                # Update training with file information
                temp_training.file_path = file_path
                temp_training.file_name = generated_filename
                temp_training.file_type = file_type
                temp_training.file_size = file_size
                temp_training.mime_type = mime_type
            
            # Create training through repository
            created_training = await training_repo.create(temp_training)
            
            return created_training
            
        except Exception as storage_error:
            
            # Try to clean up any partially stored file
            try:
                if 'file_path' in locals():
                    await file_storage.delete_training_file(file_path)
            except:
                pass  # Ignore cleanup errors
            
            logger.error(f"File storage error during training creation: {str(storage_error)}")
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="File storage error occurred"
            )
            
    except FileValidationError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except AITrainingGenerationError as e:
        await db.rollback()
        logger.error(f"AI training generation failed: {str(e)}")
        
        # Return appropriate error based on type
        if e.error_type == "rate_limit_exceeded":
            raise HTTPException(
                status_code=status.HTTP_429_TOO_MANY_REQUESTS,
                detail=str(e)
            )
        elif e.error_type in ["vertex_error", "generation_error"]:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail=str(e)
            )
        else:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=str(e)
            )
    except Exception as e:
        await db.rollback()
        logger.error(f"Training creation failed: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Training creation failed"
        )


@router.get("/", response_model=List[TrainingListResponse])
async def list_trainings(
    current_trainer: Trainer = Depends(get_current_trainer),
    db: AsyncSession = Depends(get_database_session)
):
    """List all trainings for current trainer"""
    
    training_repo = TrainingRepository(db)
    trainings = await training_repo.get_by_trainer_id(current_trainer.id)
    return trainings


@router.get("/{training_id}", response_model=TrainingResponse)
async def get_training(
    training_id: UUID,
    current_trainer: Trainer = Depends(get_current_trainer),
    db: AsyncSession = Depends(get_database_session)
):
    """Get specific training by ID"""
    
    training_repo = TrainingRepository(db)
    training = await training_repo.get_by_id(training_id)
    
    if not training:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Training not found"
        )
    
    # Check ownership
    if training.trainer_id != current_trainer.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Access denied"
        )
    
    return training


@router.delete("/{training_id}")
async def delete_training(
    training_id: UUID,
    current_trainer: Trainer = Depends(get_current_trainer),
    db: AsyncSession = Depends(get_database_session)
):
    """Delete training and associated file"""
    
    training_repo = TrainingRepository(db)
    training = await training_repo.get_by_id(training_id)
    
    if not training:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Training not found"
        )
    
    # Check ownership
    if training.trainer_id != current_trainer.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Access denied"
        )
    
    try:
        # Delete file first
        if training.file_path:
            file_storage = FileStorageService()
            await file_storage.delete_training_file(training.file_path)
        
        # Delete from database
        await training_repo.delete(training_id)
        await db.commit()
        
        return {"message": "Training deleted successfully"}
        
    except Exception as e:
        await db.rollback()
        logger.error(f"Training deletion failed for training_id {training_id}: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Training deletion failed"
        )


@router.get("/{training_id}/download")
async def download_training_file(
    training_id: UUID,
    current_trainer: Trainer = Depends(get_current_trainer),
    db: AsyncSession = Depends(get_database_session)
):
    """
    Download training file
    
    Returns the original training file with appropriate headers for download.
    Only the trainer who uploaded the file can download it.
    """
    
    training_repo = TrainingRepository(db)
    training = await training_repo.get_by_id(training_id)
    
    # Check if training exists
    if not training:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Training not found"
        )
    
    # Check ownership - only trainer who uploaded can download
    if training.trainer_id != current_trainer.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Access denied: You can only download your own training files"
        )
    
    # Check if file information exists
    if not training.file_path or not training.file_name:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Training file not found"
        )
    
    # Get file storage service and check if file exists
    file_storage = FileStorageService()
    file_exists = await file_storage.file_exists(training.file_path)
    
    if not file_exists:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Training file not found on server"
        )
    
    try:
        # Get full file path
        full_file_path = await file_storage.get_training_file_path(training.file_path)
        
        # Determine content type
        content_type = training.mime_type or "application/octet-stream"
        
        # Create appropriate filename for download
        download_filename = training.file_name or f"training_{training_id}{Path(training.file_path).suffix}"
        
        # Return file using FileResponse for better performance
        return FileResponse(
            path=str(full_file_path),
            filename=download_filename,
            media_type=content_type,
            headers={
                "Content-Disposition": f"attachment; filename=\"{download_filename}\"",
                "Content-Type": content_type,
                "Cache-Control": "no-cache, no-store, must-revalidate",
                "Pragma": "no-cache",
                "Expires": "0"
            }
        )
        
    except FileNotFoundError:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Training file not found on server"
        )
    except PermissionError:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Permission denied accessing training file"
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error downloading file: {str(e)}"
        )