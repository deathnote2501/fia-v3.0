<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FIA v3.0 - Personal Training Plan</title>
    
    <!-- Bootstrap 5.3.2 -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css" rel="stylesheet">
    
    <!-- Custom styles -->
    <link href="../src/styles/main.css" rel="stylesheet">
    
    <style>
        /* KISS: Simple markdown styling */
        .slide-content h1, .slide-content h2, .slide-content h3 {
            color: #0d6efd;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
        }
        .slide-content h1 { font-size: 1.75rem; }
        .slide-content h2 { font-size: 1.5rem; }
        .slide-content h3 { font-size: 1.25rem; }
        .slide-content ul, .slide-content ol {
            margin-bottom: 1rem;
        }
        .slide-content li {
            margin-bottom: 0.5rem;
        }
        .slide-content blockquote {
            background: #f8f9fa;
            border-left: 4px solid #0d6efd;
            padding: 1rem;
            margin: 1rem 0;
        }
        .slide-content code {
            background: #f8f9fa;
            padding: 0.2rem 0.4rem;
            border-radius: 0.25rem;
            font-size: 0.9em;
        }
        .slide-content pre {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
        }
        
        /* Live Voice Button Styles - HIDDEN UNTIL VERTEX AI INTEGRATION */
        #live-voice-btn {
            display: none !important; /* Hide Live Voice button */
            transition: all 0.3s ease;
        }
        
        #live-voice-btn.btn-danger {
            background-color: #dc3545;
            border-color: #dc3545;
        }
        
        #live-voice-btn.btn-success {
            background-color: #198754;
            border-color: #198754;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(25, 135, 84, 0.7); }
            50% { box-shadow: 0 0 0 10px rgba(25, 135, 84, 0); }
            100% { box-shadow: 0 0 0 0 rgba(25, 135, 84, 0); }
        }
        
        #live-status {
            display: none !important; /* Hide Live Voice status text */
            font-size: 0.75rem;
            min-height: 1rem;
        }
        
        /* Live session chat message styling */
        .message[data-action-type="live-voice"] .message-content {
            position: relative;
        }
        
        .message[data-action-type="live-voice"] .message-content::before {
            content: "üéôÔ∏è";
            position: absolute;
            left: -20px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.8rem;
        }
        
        .message[data-action-type="live-session"] .message-content {
            border-left: 3px solid #198754;
            padding-left: 8px;
        }
        
        /* PowerPoint-style Layout - Flat design, no shadows */
        .powerpoint-container {
            display: flex;
            height: calc(100vh - 60px); /* Subtract progress bar height */
            width: 100%;
            background: white;
        }
        
        /* Chat Panel - 25% left */
        .chat-panel {
            width: 25%;
            background: #f8f9fa;
            border-right: 1px solid #dee2e6;
            display: flex;
            flex-direction: column;
        }
        
        /* Chat Messages Area */
        .chat-messages {
            flex: 1;
            padding: 1rem;
            overflow-y: auto;
            background: white;
        }
        
        .message {
            margin-bottom: 1rem;
        }
        
        .message-content {
            padding: 0.75rem 1rem;
            border-radius: 0.375rem;
            max-width: 85%;
            word-wrap: break-word;
        }
        
        /* AI messages - gris clair standard Bootstrap */
        .ai-message .message-content {
            background-color: #f8f9fa;
            color: #495057;
            margin-left: 0;
            border: 1px solid #dee2e6;
        }
        
        /* User messages - fond bleu p√¢le comme btn-primary disabled */
        .user-message {
            display: flex;
            justify-content: flex-end;
        }
        
        .user-message .message-content {
            background-color: #b3d7ff;
            color: #004085;
            margin-right: 0;
            border: 1px solid #9fcdff;
        }
        
        /* Chat Actions */
        .chat-actions {
            padding: 0.75rem 1rem;
            background: white;
            border-top: 1px solid #dee2e6;
            border-bottom: 1px solid #dee2e6;
        }
        
        /* Chat Input */
        .chat-input {
            padding: 1rem;
            background: white;
        }
        
        .chat-status {
            font-size: 0.75rem;
            min-height: 1rem;
        }
        
        /* Voice Chat Button States */
        .voice-chat-btn {
            min-width: 2.5rem;
            transition: all 0.2s ease-in-out;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Microphone state (default - blue) */
        .voice-chat-btn.state-mic {
            background-color: #0d6efd;
            color: white;
        }
        
        .voice-chat-btn.state-mic:hover {
            background-color: #0b5ed7;
            color: white;
        }
        
        .voice-chat-btn.state-mic:active {
            background-color: #0a58ca;
            color: white;
            transform: scale(0.98);
        }
        
        /* Recording state (red) */
        .voice-chat-btn.state-recording {
            background-color: #dc3545;
            color: white;
            animation: pulse-recording 1.5s infinite;
        }
        
        .voice-chat-btn.state-recording:hover {
            background-color: #dc3545;
            color: white;
        }
        
        /* Send state (blue) */
        .voice-chat-btn.state-send {
            background-color: #0d6efd;
            color: white;
        }
        
        .voice-chat-btn.state-send:hover {
            background-color: #0b5ed7;
            color: white;
        }
        
        .voice-chat-btn.state-send:active {
            background-color: #0a58ca;
            color: white;
            transform: scale(0.98);
        }
        
        /* Disabled state */
        .voice-chat-btn:disabled {
            background-color: #6c757d;
            color: white;
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        /* Recording pulse animation */
        @keyframes pulse-recording {
            0% {
                box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(220, 53, 69, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(220, 53, 69, 0);
            }
        }
        
        /* Voice support indicator */
        .voice-not-supported {
            display: none;
        }
        
        .no-voice-support .voice-not-supported {
            display: inline;
        }
        
        .no-voice-support .voice-chat-btn {
            display: none;
        }
        
        /* Typing Animation for AI thinking */
        .typing-animation {
            display: inline-flex;
            align-items: center;
            gap: 2px;
        }
        
        .typing-dot {
            width: 6px;
            height: 6px;
            background-color: #6c757d;
            border-radius: 50%;
            animation: typing 1.5s infinite;
        }
        
        .typing-dot:nth-child(1) {
            animation-delay: 0s;
        }
        
        .typing-dot:nth-child(2) {
            animation-delay: 0.2s;
        }
        
        .typing-dot:nth-child(3) {
            animation-delay: 0.4s;
        }
        
        @keyframes typing {
            0%, 60%, 100% {
                transform: translateY(0);
            }
            30% {
                transform: translateY(-8px);
            }
        }
        
        /* Content Panel - 75% right */
        .content-panel {
            width: 75%;
            background: white;
            display: flex;
            flex-direction: column;
        }
        
        /* Progress Bar */
        .progress-bar-container {
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
            padding: 0.75rem 1.5rem;
        }
        
        .progress-breadcrumb {
            font-size: 0.9rem;
            color: #6c757d;
        }
        
        .progress-text {
            font-weight: 500;
        }
        
        .progress-text .current-module {
            color: #0d6efd;
            font-weight: 600;
        }
        
        /* Slide Content Area (scrollable only) */
        .slide-content-area {
            flex: 1;
            padding: 2rem;
            overflow-y: auto;
            background: white;
        }
        
        /* Navigation Bar (fixed at bottom) */
        .navigation-bar {
            background: #f8f9fa;
            border-top: 1px solid #dee2e6;
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .interaction-buttons {
            display: flex;
            align-items: center;
        }
        
        /* Remove Bootstrap shadows for flat design, keep standard rounded corners */
        .btn {
            box-shadow: none !important;
        }
        
        .card {
            box-shadow: none !important;
        }
        
        .form-control {
            box-shadow: none !important;
        }
        
        /* Prevent body scrollbar */
        body {
            overflow: hidden;
        }
    </style>
</head>
<body class="bg-white">
    
    <!-- Progress Bar - Full Width at Top -->
    <div class="progress-bar-container">
        <div id="progress-breadcrumb" class="progress-breadcrumb">
            <span class="progress-text">Training Plan</span>
        </div>
    </div>
    
    <!-- PowerPoint-style Layout: 25% Chat + 75% Content -->
    <div class="powerpoint-container">
        <!-- Left Panel: Chat IA (25%) -->
        <div class="chat-panel">
            <!-- Chat Messages Area (scrollable) -->
            <div class="chat-messages" id="chat-messages">
                <!-- Messages will be added dynamically here -->
            </div>
            
            <!-- Action Buttons -->
            <div class="chat-actions">
                <div class="btn-group w-100" role="group" aria-label="Chat actions">
                    <button type="button" class="btn btn-outline-primary btn-sm" id="comment-btn">
                        <i class="bi bi-chat-text me-1"></i>Comment
                    </button>
                    <button type="button" class="btn btn-outline-primary btn-sm" id="quiz-btn">
                        <i class="bi bi-question-circle me-1"></i>Quiz
                    </button>
                    <button type="button" class="btn btn-outline-primary btn-sm" id="examples-btn">
                        <i class="bi bi-lightbulb me-1"></i>Examples
                    </button>
                    <button type="button" class="btn btn-outline-primary btn-sm" id="key-points-btn">
                        <i class="bi bi-star me-1"></i>Key Points
                    </button>
                </div>
            </div>
            
            <!-- Chat Input (fixed at bottom) -->
            <div class="chat-input">
                <div class="input-group">
                    <input type="text" class="form-control" id="chat-input" 
                           placeholder="Ask your AI trainer..." maxlength="500">
                    
                    <!-- Voice Chat Button (adaptive) -->
                    <button class="btn voice-chat-btn state-mic" type="button" id="voice-chat-btn" 
                            title="Click to start voice recording">
                        <i class="bi bi-mic" id="voice-btn-icon"></i>
                    </button>
                    
                    <!-- Fallback text for unsupported browsers -->
                    <span class="voice-not-supported">
                        <button class="btn btn-primary" type="button" id="send-message-btn-fallback">
                            <i class="bi bi-send"></i>
                        </button>
                    </span>
                </div>
                
                <!-- Voice status indicator -->
                <div class="chat-status" id="voice-status"></div>
            </div>
        </div>
        
        <!-- Right Panel: Content Area (75%) -->
        <div class="content-panel">
            <!-- Slide Content Area (scrollable) -->
            <div id="main-content" class="slide-content-area">
                <!-- Content will be loaded dynamically -->
            </div>
            
            <!-- Navigation Bar (fixed at bottom) -->
            <div class="navigation-bar">
                <button id="new-previous-btn" class="btn btn-outline-secondary" disabled>
                    <i class="bi bi-chevron-left me-1"></i>Previous
                </button>
                
                <div class="interaction-buttons">
                    <button id="new-simplify-btn" class="btn btn-outline-primary me-2">
                        <i class="bi bi-arrow-down-circle me-1"></i>Simplify
                    </button>
                    <button id="new-more-details-btn" class="btn btn-outline-primary">
                        <i class="bi bi-arrow-up-circle me-1"></i>Deepen
                    </button>
                </div>
                
                <button id="new-next-btn" class="btn btn-outline-primary">
                    Next<i class="bi bi-chevron-right ms-1"></i>
                </button>
            </div>
        </div>
    </div>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Marked.js for markdown parsing (KISS solution) -->
    <script src="https://cdn.jsdelivr.net/npm/marked@9.1.6/marked.min.js"></script>
    
    <script>
        // ============================================================================
        // VOICE CHAT HANDLER - Web Speech API Integration
        // ============================================================================
        
        class VoiceChatHandler {
            constructor(language = 'fr-FR') {
                this.language = language;
                this.recognition = null;
                this.isSupported = this.checkSupport();
                this.isListening = false;
                this.hasPermission = false;
                
                // Callbacks for integration with main app
                this.onResult = null;
                this.onError = null;
                this.onStart = null;
                this.onEnd = null;
                
                console.log('üé§ [VOICE] VoiceChatHandler initialized:', {
                    supported: this.isSupported,
                    language: this.language
                });
            }
            
            /**
             * Check if Web Speech API is supported in current browser
             */
            checkSupport() {
                const hasWebkitSpeech = 'webkitSpeechRecognition' in window;
                const hasSpeech = 'SpeechRecognition' in window;
                
                console.log('üé§ [VOICE] Browser support check:', {
                    webkitSpeechRecognition: hasWebkitSpeech,
                    SpeechRecognition: hasSpeech,
                    userAgent: navigator.userAgent
                });
                
                return hasWebkitSpeech || hasSpeech;
            }
            
            /**
             * Check if Web Speech API is supported
             */
            isApiSupported() {
                return this.isSupported;
            }
            
            /**
             * Request microphone permissions
             */
            async requestPermissions() {
                try {
                    console.log('üé§ [VOICE] Requesting microphone permissions...');
                    
                    // Test microphone access
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    
                    // Stop the test stream immediately
                    stream.getTracks().forEach(track => track.stop());
                    
                    this.hasPermission = true;
                    console.log('‚úÖ [VOICE] Microphone permissions granted');
                    return true;
                    
                } catch (error) {
                    console.error('‚ùå [VOICE] Microphone permission denied:', error);
                    this.hasPermission = false;
                    return false;
                }
            }
            
            /**
             * Initialize speech recognition with proper configuration
             */
            initRecognition() {
                if (!this.isSupported) {
                    console.error('‚ùå [VOICE] Speech recognition not supported');
                    return false;
                }
                
                try {
                    // Create recognition instance
                    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    this.recognition = new SpeechRecognition();
                    
                    // Configure recognition settings
                    this.recognition.continuous = true;           // Keep listening continuously
                    this.recognition.interimResults = true;       // Get partial results
                    this.recognition.maxAlternatives = 1;         // Only best result
                    this.recognition.lang = this.language;        // Set language
                    
                    // Configure timeout for silence (10 seconds)
                    this.recognition.speechTimeoutLength = 10000;
                    
                    // Setup event handlers
                    this.setupRecognitionEvents();
                    
                    console.log('‚úÖ [VOICE] Speech recognition initialized:', {
                        continuous: this.recognition.continuous,
                        interimResults: this.recognition.interimResults,
                        language: this.recognition.lang
                    });
                    
                    return true;
                    
                } catch (error) {
                    console.error('‚ùå [VOICE] Failed to initialize speech recognition:', error);
                    return false;
                }
            }
            
            /**
             * Setup speech recognition event handlers
             */
            setupRecognitionEvents() {
                if (!this.recognition) return;
                
                // Recognition started
                this.recognition.onstart = () => {
                    console.log('üé§ [VOICE] Recognition started');
                    this.isListening = true;
                    if (this.onStart) this.onStart();
                };
                
                // Recognition ended
                this.recognition.onend = () => {
                    console.log('üé§ [VOICE] Recognition ended');
                    this.isListening = false;
                    if (this.onEnd) this.onEnd();
                };
                
                // Recognition result received
                this.recognition.onresult = (event) => {
                    console.log('üé§ [VOICE] Recognition result:', event);
                    
                    let transcript = '';
                    let isFinal = false;
                    
                    // Process all results
                    for (let i = event.resultIndex; i < event.results.length; i++) {
                        const result = event.results[i];
                        transcript += result[0].transcript;
                        
                        if (result.isFinal) {
                            isFinal = true;
                        }
                    }
                    
                    console.log('üé§ [VOICE] Transcript:', {
                        text: transcript,
                        isFinal: isFinal,
                        confidence: event.results[0]?.[0]?.confidence
                    });
                    
                    // Call result callback
                    if (this.onResult) {
                        this.onResult(transcript, isFinal);
                    }
                };
                
                // Recognition error
                this.recognition.onerror = (event) => {
                    console.error('‚ùå [VOICE] Recognition error:', event.error);
                    
                    const errorMessage = this.getErrorMessage(event.error);
                    
                    if (this.onError) {
                        this.onError(event.error, errorMessage);
                    }
                };
            }
            
            /**
             * Get user-friendly error message
             */
            getErrorMessage(error) {
                const errorMessages = {
                    'not-allowed': 'Microphone access denied. Please allow microphone permissions.',
                    'no-speech': 'No speech detected. Please speak clearly.',
                    'audio-capture': 'Microphone not available. Please check your microphone.',
                    'network': 'Network error. Please check your internet connection.',
                    'service-not-allowed': 'Speech recognition service not allowed.',
                    'bad-grammar': 'Speech recognition grammar error.',
                    'language-not-supported': 'Selected language not supported for speech recognition.'
                };
                
                return errorMessages[error] || `Speech recognition error: ${error}`;
            }
            
            /**
             * Set the recognition language
             */
            setLanguage(language) {
                this.language = language;
                if (this.recognition) {
                    this.recognition.lang = language;
                }
                console.log('üé§ [VOICE] Language set to:', language);
            }
            
            /**
             * Start speech recognition
             */
            async startRecognition() {
                if (!this.isSupported) {
                    throw new Error('Speech recognition not supported in this browser');
                }
                
                if (!this.hasPermission) {
                    const hasPermission = await this.requestPermissions();
                    if (!hasPermission) {
                        throw new Error('Microphone permission required');
                    }
                }
                
                if (!this.recognition) {
                    const initialized = this.initRecognition();
                    if (!initialized) {
                        throw new Error('Failed to initialize speech recognition');
                    }
                }
                
                if (this.isListening) {
                    console.log('üé§ [VOICE] Already listening, ignoring start request');
                    return;
                }
                
                try {
                    console.log('üé§ [VOICE] Starting recognition...');
                    this.recognition.start();
                } catch (error) {
                    console.error('‚ùå [VOICE] Failed to start recognition:', error);
                    throw error;
                }
            }
            
            /**
             * Stop speech recognition
             */
            stopRecognition() {
                if (!this.recognition || !this.isListening) {
                    console.log('üé§ [VOICE] Not listening, ignoring stop request');
                    return;
                }
                
                try {
                    console.log('üé§ [VOICE] Stopping recognition...');
                    this.recognition.stop();
                } catch (error) {
                    console.error('‚ùå [VOICE] Failed to stop recognition:', error);
                }
            }
            
            /**
             * Get current status
             */
            getStatus() {
                return {
                    isSupported: this.isSupported,
                    hasPermission: this.hasPermission,
                    isListening: this.isListening,
                    language: this.language
                };
            }
        }
        
        // ============================================================================
        // TRAINING APPLICATION
        // ============================================================================
        
        class TrainingApp {
            constructor() {
                this.container = document.getElementById('main-content');
                this.token = this.getTokenFromURL();
                this.sessionData = null;
                this.learnerSession = null;
                this.currentSlide = null; // Track current slide for navigation
                
                // Initialize Voice Chat Handler
                this.voiceHandler = null;
                this.currentButtonState = 'mic'; // 'mic', 'recording', 'send'
                
                if (!this.token) {
                    this.showError('No session token provided');
                    return;
                }
                
                this.init();
            }
            
            getTokenFromURL() {
                const urlParams = new URLSearchParams(window.location.search);
                return urlParams.get('token');
            }
            
            async init() {
                try {
                    console.log('üöÄ Initializing TrainingApp with token:', this.token);
                    await this.loadLearnerData();
                    await this.displayTrainingPlan();
                } catch (error) {
                    console.error('Training app initialization error:', error);
                    this.showError(error.message);
                }
            }
            
            async loadLearnerData() {
                try {
                    console.log('üîç Loading learner data for token:', this.token);
                    
                    // Validate session token first
                    const sessionResponse = await fetch(`/api/session/${this.token}`);
                    if (!sessionResponse.ok) {
                        throw new Error('Invalid or expired session token');
                    }
                    
                    const sessionData = await sessionResponse.json();
                    console.log('‚úÖ Session data loaded:', sessionData);
                    
                    this.sessionData = sessionData;
                    this.learnerSession = sessionData.learner_session;
                    
                    // Update UI with learner info (removed UI element, keeping data)
                    if (this.learnerSession) {
                        console.log('‚úÖ Learner session loaded:', this.learnerSession.email);
                    }
                    
                } catch (error) {
                    console.error('‚ùå Error loading learner data:', error);
                    throw new Error(`Failed to load training data: ${error.message}`);
                }
            }
            
            async displayTrainingPlan() {
                // Afficher le loading d'abord
                this.showLoading();
                
                try {
                    console.log('üöÄ Starting training plan generation...');
                    
                    // V√©rifier qu'on a les donn√©es n√©cessaires
                    if (!this.learnerSession) {
                        console.log('‚ö†Ô∏è No learner session data available, redirecting to profile page...');
                        // Rediriger vers la page de profil si pas de donn√©es learner
                        window.location.href = `/frontend/public/session.html?token=${this.token}`;
                        return;
                    }
                    
                    if (!this.sessionData?.training_session?.training_id) {
                        throw new Error('No training ID available');
                    }
                    
                    // Pr√©parer la requ√™te de g√©n√©ration de plan
                    const planRequest = {
                        training_id: this.sessionData.training_session.training_id,
                        learner_session_id: this.learnerSession.id,
                        learner_profile: {
                            experience_level: this.learnerSession.experience_level,
                            learning_style: this.learnerSession.learning_style,
                            job_position: this.learnerSession.job_position,
                            activity_sector: this.learnerSession.activity_sector,
                            country: this.learnerSession.country,
                            language: this.learnerSession.language
                        },
                        force_regenerate: false
                    };
                    
                    console.log('üìù Plan generation request:', planRequest);
                    
                    // Appeler l'API de g√©n√©ration de plans int√©gr√©e
                    console.log('üîÑ Calling /api/generate-plan-integrated...');
                    const planResponse = await fetch('/api/generate-plan-integrated', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(planRequest)
                    });
                    
                    console.log('üìä Plan response status:', planResponse.status);
                    console.log('üìä Plan response headers:', [...planResponse.headers.entries()]);
                    
                    if (!planResponse.ok) {
                        const errorText = await planResponse.text();
                        console.error('‚ùå Plan generation failed - Raw response:', errorText);
                        
                        let errorData;
                        try {
                            errorData = JSON.parse(errorText);
                        } catch (e) {
                            errorData = { detail: { error_message: errorText } };
                        }
                        
                        console.error('‚ùå Plan generation failed:', errorData);
                        throw new Error(`Plan generation failed: ${errorData.detail?.error_message || planResponse.statusText}`);
                    }
                    
                    const planData = await planResponse.json();
                    console.log('‚úÖ Plan generated successfully:', planData);
                    
                    // Au lieu d'afficher l'ancienne page de plan, aller directement √† la premi√®re slide
                    console.log('üéØ Plan g√©n√©r√© avec succ√®s, redirection vers premi√®re slide...');
                    await this.loadAndDisplayCurrentSlide();
                    
                } catch (error) {
                    console.error('‚ùå Error generating training plan:', error);
                    this.showError(`Failed to generate training plan: ${error.message}`);
                }
            }
            
            showLoading() {
                this.container.innerHTML = `
                    <div class="row">
                        <div class="col-12">
                            <div class="text-center py-5">
                                <div class="spinner-border text-primary mb-3" role="status" style="width: 3rem; height: 3rem;">
                                    <span class="visually-hidden">Loading...</span>
                                </div>
                                <h5>Generating Your Personalized Training Plan</h5>
                                <p class="text-muted">
                                    Our AI is analyzing your profile and creating a customized learning experience...
                                    <br>This may take a few moments.
                                </p>
                                <div class="progress mt-3" style="height: 6px;">
                                    <div class="progress-bar progress-bar-striped progress-bar-animated" 
                                         role="progressbar" style="width: 100%"></div>
                                </div>
                                
                                <div class="mt-4">
                                    <small class="text-muted">
                                        <strong>Debug Info:</strong><br>
                                        Session Token: ${this.token}<br>
                                        Training ID: ${this.sessionData?.training_session?.training_id || 'Loading...'}<br>
                                        Learner Email: ${this.learnerSession?.email || 'Loading...'}
                                    </small>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            
            async loadAndDisplayCurrentSlide() {
                try {
                    console.log('üéØ [API] === D√âBUT R√âCUP√âRATION SLIDE COURANTE ===');
                    console.log('üéØ [API] Session ID:', this.learnerSession.id);
                    
                    // Afficher loading pendant r√©cup√©ration/g√©n√©ration
                    this.showSlideLoading();
                    
                    // Appeler l'API pour r√©cup√©rer la slide courante (reprise de session)
                    console.log('üîÑ [API] Appel API /api/slides/get-current/${this.learnerSession.id}');
                    const response = await fetch(`/api/slides/get-current/${this.learnerSession.id}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    console.log('üì° [API] RESPONSE STATUS:', response.status);
                    console.log('üì° [API] RESPONSE OK:', response.ok);
                    console.log('üì° [API] RESPONSE HEADERS:', [...response.headers.entries()]);
                    
                    if (!response.ok) {
                        console.log('‚ùå [API] RESPONSE NOT OK - R√©cup√©ration erreur...');
                        const errorData = await response.json();
                        console.log('‚ùå [API] ERROR DATA:', errorData);
                        throw new Error(errorData.detail || 'Failed to get current slide');
                    }
                    
                    console.log('üîÑ [API] Parsing JSON response...');
                    const slideData = await response.json();
                    console.log('‚úÖ [API] SLIDE DATA RE√áUE (COMPLET):', slideData);
                    
                    // Log si on reprend une session en cours
                    if (slideData.data && slideData.data.is_resuming) {
                        console.log('üîÑ [SESSION] REPRISE DE SESSION D√âTECT√âE - Slide #' + slideData.data.slide_number);
                    } else {
                        console.log('üÜï [SESSION] NOUVELLE SESSION - D√©but de formation');
                    }
                    console.log('‚úÖ [API] SLIDE DATA TYPE:', typeof slideData);
                    console.log('‚úÖ [API] SLIDE DATA KEYS:', Object.keys(slideData));
                    
                    if (slideData.data) {
                        console.log('üîç [API] slideData.data TYPE:', typeof slideData.data);
                        console.log('üîç [API] slideData.data KEYS:', Object.keys(slideData.data));
                        console.log('üîç [API] slideData.data COMPLET:', slideData.data);
                        
                        if (slideData.data.title) {
                            console.log('üìã [API] TITRE D√âTECT√â:', slideData.data.title);
                        }
                        if (slideData.data.slide_content) {
                            console.log('üìã [API] SLIDE_CONTENT D√âTECT√â (longueur):', slideData.data.slide_content.length);
                            console.log('üìã [API] SLIDE_CONTENT PREVIEW:', slideData.data.slide_content.substring(0, 150) + '...');
                        }
                        if (slideData.data.content) {
                            console.log('üìã [API] CONTENT D√âTECT√â (longueur):', slideData.data.content.length);
                            console.log('üìã [API] CONTENT PREVIEW:', slideData.data.content.substring(0, 150) + '...');
                        }
                    } else {
                        console.log('‚ö†Ô∏è [API] PAS DE slideData.data - Structure diff√©rente?');
                        console.log('üîç [API] Analyse structure alternative...');
                        if (slideData.title) {
                            console.log('üìã [API] TITRE DIRECT:', slideData.title);
                        }
                        if (slideData.slide_content) {
                            console.log('üìã [API] SLIDE_CONTENT DIRECT:', slideData.slide_content.substring(0, 150) + '...');
                        }
                    }
                    
                    console.log('üé® [API] === PASSAGE √Ä DISPLAYSLIDE ===');
                    // Afficher la slide - passer les bonnes donn√©es
                    this.displaySlideContent(slideData.data || slideData);
                    
                } catch (error) {
                    console.error('‚ùå [API] ERROR loadAndDisplayCurrentSlide:', error);
                    console.error('‚ùå [API] ERROR STACK:', error.stack);
                    throw error;
                }
            }
            
            showSlideLoading() {
                this.container.innerHTML = `
                    <div class="row">
                        <div class="col-lg-12">
                            <div class="card shadow-sm">
                                <div class="card-body text-center py-5">
                                    <div class="spinner-border text-primary mb-3" role="status" style="width: 3rem; height: 3rem;">
                                        <span class="visually-hidden">Loading...</span>
                                    </div>
                                    <h5 class="card-title">Generating Your First Slide</h5>
                                    <p class="card-text text-muted">
                                        Our AI is creating personalized content based on your profile...
                                    </p>
                                    <div class="progress mt-3" style="height: 6px;">
                                        <div class="progress-bar progress-bar-striped progress-bar-animated" 
                                             role="progressbar" style="width: 100%"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            displaySlideContent(slideData) {
                // Store current slide data for navigation
                this.currentSlide = slideData;
                console.log('üé® [DISPLAY] === D√âBUT ANALYSE DES DONN√âES ===');
                console.log('üé® [DISPLAY] slideData TYPE:', typeof slideData);
                console.log('üé® [DISPLAY] slideData COMPLET:', slideData);
                console.log('üé® [DISPLAY] slideData.title:', slideData.title);
                console.log('üé® [DISPLAY] slideData.slide_content:', slideData.slide_content);
                console.log('üé® [DISPLAY] slideData.content:', slideData.content);
                console.log('üé® [DISPLAY] slideData.slide:', slideData.slide);
                
                // KISS: Extract content directly from the data structure
                // slideData peut contenir slide_content (format JSON), content, ou slide.content
                let title, content;
                
                // Priorit√©: slide_content d'abord (peu importe si title existe)
                if (slideData.slide_content) {
                    console.log('üéØ [DISPLAY] BRANCHE 1: slide_content d√©tect√© (priorit√© haute)');
                    title = slideData.title || 'Formation Content';
                    content = slideData.slide_content;
                    console.log('üéØ [DISPLAY] BRANCHE 1: title =', title);
                    console.log('üéØ [DISPLAY] BRANCHE 1: content =', content);
                } else if (slideData.title && slideData.content) {
                    // Structure directe
                    console.log('üéØ [DISPLAY] BRANCHE 2: title + content d√©tect√©s');
                    title = slideData.title;
                    content = slideData.content;
                    console.log('üéØ [DISPLAY] BRANCHE 2: title =', title);
                    console.log('üéØ [DISPLAY] BRANCHE 2: content =', content);
                } else if (slideData.slide) {
                    // Structure avec "slide" wrapper
                    console.log('üéØ [DISPLAY] BRANCHE 3: slide wrapper d√©tect√©');
                    title = slideData.slide.title;
                    content = slideData.slide.content || slideData.slide.slide_content;
                    console.log('üéØ [DISPLAY] BRANCHE 3: title =', title);
                    console.log('üéØ [DISPLAY] BRANCHE 3: content =', content);
                } else {
                    // Fallback - essayer de parser si c'est un JSON string contenant slide_content
                    console.log('üéØ [DISPLAY] BRANCHE 4: FALLBACK - tentative parsing JSON');
                    try {
                        if (typeof slideData === 'string') {
                            const parsed = JSON.parse(slideData);
                            if (parsed.slide_content) {
                                console.log('üéØ [DISPLAY] BRANCHE 4: JSON pars√© avec slide_content trouv√©');
                                title = parsed.title || 'Formation Content';
                                content = parsed.slide_content;
                            } else {
                                throw new Error('No slide_content in parsed JSON');
                            }
                        } else {
                            throw new Error('Not a JSON string');
                        }
                    } catch (e) {
                        console.log('üéØ [DISPLAY] BRANCHE 4: VRAI FALLBACK utilis√©');
                        title = 'Formation Content';
                        content = slideData.content || JSON.stringify(slideData);
                    }
                    console.log('üéØ [DISPLAY] BRANCHE 4: title =', title);
                    console.log('üéØ [DISPLAY] BRANCHE 4: content =', content);
                }
                
                console.log('üìù [DISPLAY] EXTRACTION FINALE:');
                console.log('üìù [DISPLAY] title FINAL =', title);
                console.log('üìù [DISPLAY] content FINAL (type):', typeof content);
                console.log('üìù [DISPLAY] content FINAL (longueur):', content ? content.length : 'NULL');
                console.log('üìù [DISPLAY] content FINAL (preview):', content ? content.substring(0, 100) + '...' : 'NULL');
                console.log('üé® [DISPLAY] === AVANT PASSAGE √Ä MARKDOWN ===');
                
                // CORRECTION: V√©rifier si le contenu est un objet JSON avec slide_content
                if (typeof content === 'object' && content !== null && content.slide_content) {
                    console.log('üîß [DISPLAY] CORRECTION: Contenu est un objet JSON avec slide_content');
                    content = content.slide_content;
                    console.log('üîß [DISPLAY] CORRECTION: Contenu extrait:', content.substring(0, 100) + '...');
                } else if (typeof content === 'string' && content.startsWith('{') && content.includes('slide_content')) {
                    console.log('üîß [DISPLAY] CORRECTION: Contenu est une string JSON avec slide_content');
                    try {
                        const parsed = JSON.parse(content);
                        if (parsed.slide_content) {
                            content = parsed.slide_content;
                            console.log('üîß [DISPLAY] CORRECTION: Contenu extrait depuis JSON string:', content.substring(0, 100) + '...');
                        }
                    } catch (e) {
                        console.log('üîß [DISPLAY] CORRECTION: √âchec parsing JSON, utilisation contenu original');
                    }
                }
                
                // Stocker le contenu markdown original pour les fonctionnalit√©s d'interaction
                this.currentSlideContent = content;
                console.log('üíæ [DISPLAY] Current slide content stored for interactions');
                
                // Mettre √† jour le fil d'Ariane (breadcrumb)
                this.updateBreadcrumb(slideData);
                
                this.container.innerHTML = `
                    <div class="row">
                        <!-- Main slide content (full width) -->
                        <div class="col-lg-12">
                            <!-- Slide content in markdown format -->
                            <div id="slide-content" class="slide-content">
                                ${this.markdownToHtml(content)}
                            </div>
                        </div>
                    </div>
                `;
                
                // Ajouter event listeners pour le chat
                this.setupChatFunctionality();
                this.setupContextualChatButtons();
                this.setupSlideInteractionButtons();
                this.setupNewNavigationButtons(); // Connect new navigation buttons
                this.setupLiveVoiceFunctionality();
                
                // Update navigation button states
                this.updateNavigationButtonStates();
            }
            
            markdownToHtml(markdown) {
                console.log('üìñüìñüìñ [MARKDOWN] ============== D√âBUT TRAITEMENT MARKDOWN ==============');
                console.log('üìñüìñüìñ [MARKDOWN] markdown TYPE:', typeof markdown);
                console.log('üìñüìñüìñ [MARKDOWN] markdown NULL/UNDEFINED?', markdown == null);
                console.log('üìñüìñüìñ [MARKDOWN] markdown LONGUEUR:', markdown ? markdown.length : 'N/A');
                console.log('üìñüìñüìñ [MARKDOWN] markdown IS STRING?:', typeof markdown === 'string');
                console.log('üìñüìñüìñ [MARKDOWN] markdown PREVIEW (300 chars):');
                console.log('üìñüìñüìñ [MARKDOWN] ---START PREVIEW---');
                console.log(markdown ? markdown.substring(0, 300) : 'NULL');
                console.log('üìñüìñüìñ [MARKDOWN] ---END PREVIEW---');
                console.log('üìñüìñüìñ [MARKDOWN] marked DISPONIBLE?:', typeof marked !== 'undefined');
                console.log('üìñüìñüìñ [MARKDOWN] marked.parse DISPONIBLE?:', typeof marked?.parse === 'function');
                
                // Analyse d√©taill√©e du contenu
                if (markdown) {
                    console.log('üîçüîçüîç [MARKDOWN] ANALYSE D√âTAILL√âE DU CONTENU:');
                    console.log('üîçüîçüîç [MARKDOWN] Contient des # (titres)?', markdown.includes('#'));
                    console.log('üîçüîçüîç [MARKDOWN] Contient des * (listes)?', markdown.includes('*'));
                    console.log('üîçüîçüîç [MARKDOWN] Contient des | (tableaux)?', markdown.includes('|'));
                    console.log('üîçüîçüîç [MARKDOWN] Contient des \\n (sauts de ligne)?', markdown.includes('\n'));
                    console.log('üîçüîçüîç [MARKDOWN] Nombre de sauts de ligne:', (markdown.match(/\n/g) || []).length);
                    
                    // Afficher les premi√®res et derni√®res lignes
                    const lines = markdown.split('\n');
                    console.log('üîçüîçüîç [MARKDOWN] Nombre total de lignes:', lines.length);
                    console.log('üîçüîçüîç [MARKDOWN] Premi√®res 5 lignes:');
                    lines.slice(0, 5).forEach((line, index) => {
                        console.log(`üîçüîçüîç [MARKDOWN] Ligne ${index + 1}: "${line}"`);
                    });
                    
                    if (lines.length > 10) {
                        console.log('üîçüîçüîç [MARKDOWN] ... (lignes interm√©diaires cach√©es) ...');
                        console.log('üîçüîçüîç [MARKDOWN] Derni√®res 3 lignes:');
                        lines.slice(-3).forEach((line, index) => {
                            console.log(`üîçüîçüîç [MARKDOWN] Ligne ${lines.length - 3 + index + 1}: "${line}"`);
                        });
                    }
                }
                
                if (!markdown) {
                    console.log('‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è [MARKDOWN] CONTENU VIDE - Retour message par d√©faut');
                    const defaultHtml = '<p>Content is being generated...</p>';
                    console.log('üîÑüîÑüîÑ [MARKDOWN] DEFAULT HTML:', defaultHtml);
                    return defaultHtml;
                }
                
                try {
                    console.log('üîÑüîÑüîÑ [MARKDOWN] D√âBUT PARSING avec marked.parse...');
                    console.log('üîÑüîÑüîÑ [MARKDOWN] Input exact pour marked.parse:');
                    console.log('üîÑüîÑüîÑ [MARKDOWN] ---START INPUT---');
                    console.log(markdown.substring(0, 500));
                    console.log('üîÑüîÑüîÑ [MARKDOWN] ---END INPUT---');
                    
                    // KISS: Use marked.js for proper markdown parsing
                    const htmlResult = marked.parse(markdown);
                    
                    console.log('‚úÖ‚úÖ‚úÖ [MARKDOWN] PARSING R√âUSSI!');
                    console.log('üìùüìùüìù [MARKDOWN] HTML R√âSULTAT TYPE:', typeof htmlResult);
                    console.log('üìùüìùüìù [MARKDOWN] HTML R√âSULTAT LONGUEUR:', htmlResult ? htmlResult.length : 'N/A');
                    console.log('üìùüìùüìù [MARKDOWN] HTML R√âSULTAT IS STRING?:', typeof htmlResult === 'string');
                    console.log('üìùüìùüìù [MARKDOWN] HTML R√âSULTAT PREVIEW (400 chars):');
                    console.log('üìùüìùüìù [MARKDOWN] ---START HTML RESULT---');
                    console.log(htmlResult ? htmlResult.substring(0, 400) + '...' : 'NULL');
                    console.log('üìùüìùüìù [MARKDOWN] ---END HTML RESULT---');
                    
                    // Analyser le HTML g√©n√©r√©
                    if (htmlResult) {
                        console.log('üîçüîçüîç [MARKDOWN] ANALYSE HTML G√âN√âR√â:');
                        console.log('üîçüîçüîç [MARKDOWN] Contient <h1>?', htmlResult.includes('<h1>'));
                        console.log('üîçüîçüîç [MARKDOWN] Contient <h2>?', htmlResult.includes('<h2>'));
                        console.log('üîçüîçüîç [MARKDOWN] Contient <ul>?', htmlResult.includes('<ul>'));
                        console.log('üîçüîçüîç [MARKDOWN] Contient <table>?', htmlResult.includes('<table>'));
                        console.log('üîçüîçüîç [MARKDOWN] Contient <p>?', htmlResult.includes('<p>'));
                        
                        // Compter les balises
                        const h1Count = (htmlResult.match(/<h1>/g) || []).length;
                        const h2Count = (htmlResult.match(/<h2>/g) || []).length;
                        const tableCount = (htmlResult.match(/<table>/g) || []).length;
                        const pCount = (htmlResult.match(/<p>/g) || []).length;
                        
                        console.log('üîçüîçüîç [MARKDOWN] Nombre de <h1>:', h1Count);
                        console.log('üîçüîçüîç [MARKDOWN] Nombre de <h2>:', h2Count);
                        console.log('üîçüîçüîç [MARKDOWN] Nombre de <table>:', tableCount);
                        console.log('üîçüîçüîç [MARKDOWN] Nombre de <p>:', pCount);
                    }
                    
                    console.log('üìñüìñüìñ [MARKDOWN] ============== FIN TRAITEMENT MARKDOWN SUCC√àS ==============');
                    return htmlResult;
                    
                } catch (error) {
                    console.error('‚ùå‚ùå‚ùå [MARKDOWN] ERREUR PARSING:', error);
                    console.error('‚ùå‚ùå‚ùå [MARKDOWN] ERROR MESSAGE:', error.message);
                    console.error('‚ùå‚ùå‚ùå [MARKDOWN] ERROR STACK:', error.stack);
                    console.log('üîÑüîÑüîÑ [MARKDOWN] FALLBACK: Conversion simple \\n -> <br>');
                    
                    // Fallback to plain text with line breaks
                    const fallbackResult = markdown.replace(/\n/g, '<br>');
                    console.log('üìùüìùüìù [MARKDOWN] FALLBACK R√âSULTAT LONGUEUR:', fallbackResult.length);
                    console.log('üìùüìùüìù [MARKDOWN] FALLBACK R√âSULTAT PREVIEW (300 chars):', fallbackResult.substring(0, 300) + '...');
                    console.log('üìñüìñüìñ [MARKDOWN] ============== FIN TRAITEMENT MARKDOWN FALLBACK ==============');
                    return fallbackResult;
                }
            }
            
            setupChatFunctionality() {
                const chatInput = document.getElementById('chat-input');
                const voiceChatBtn = document.getElementById('voice-chat-btn');
                const voiceBtnIcon = document.getElementById('voice-btn-icon');
                const voiceStatus = document.getElementById('voice-status');
                const chatMessages = document.getElementById('chat-messages');
                const sendBtnFallback = document.getElementById('send-message-btn-fallback');
                
                // Initialize voice handler based on learner language
                this.initializeVoiceHandler();
                
                // Setup fallback for unsupported browsers
                this.setupVoiceFallback(sendBtnFallback, chatInput);
                
                if (chatInput && voiceChatBtn && chatMessages) {
                    // Setup input change listener for adaptive button behavior
                    this.setupInputChangeListener(chatInput, voiceChatBtn, voiceBtnIcon);
                    
                    // The actual send message and voice logic will be added in Phase 3 & 4
                    console.log('‚úÖ [CHAT] Chat functionality initialized with voice support');
                } else {
                    console.error('‚ùå [CHAT] Missing chat elements');
                }
            }
            
            /**
             * Initialize voice handler with learner's language
             */
            initializeVoiceHandler() {
                // Map learner language to speech recognition language codes
                const languageMap = {
                    'fr': 'fr-FR',
                    'en': 'en-US', 
                    'es': 'es-ES',
                    'de': 'de-DE'
                };
                
                const learnerLang = this.learnerSession?.language || 'fr';
                const speechLang = languageMap[learnerLang] || 'fr-FR';
                
                this.voiceHandler = new VoiceChatHandler(speechLang);
                
                // Check if voice is supported
                if (!this.voiceHandler.isApiSupported()) {
                    console.log('üé§ [VOICE] Web Speech API not supported, showing fallback');
                    this.showVoiceFallback();
                } else {
                    console.log('‚úÖ [VOICE] Voice handler initialized with language:', speechLang);
                }
            }
            
            /**
             * Setup voice fallback for unsupported browsers
             */
            setupVoiceFallback(fallbackBtn, chatInput) {
                if (fallbackBtn) {
                    fallbackBtn.addEventListener('click', () => {
                        this.sendChatMessage(chatInput.value.trim());
                    });
                }
            }
            
            /**
             * Show voice fallback UI
             */
            showVoiceFallback() {
                const chatInputContainer = document.querySelector('.chat-input');
                if (chatInputContainer) {
                    chatInputContainer.classList.add('no-voice-support');
                }
            }
            
            /**
             * Setup input change listener for adaptive button behavior
             */
            setupInputChangeListener(chatInput, voiceChatBtn, voiceBtnIcon) {
                const updateButtonState = () => {
                    const hasText = chatInput.value.trim().length > 0;
                    
                    if (hasText && this.currentButtonState !== 'send') {
                        // Switch to send mode
                        this.setButtonState('send', voiceChatBtn, voiceBtnIcon);
                    } else if (!hasText && this.currentButtonState !== 'mic' && this.currentButtonState !== 'recording') {
                        // Switch back to mic mode
                        this.setButtonState('mic', voiceChatBtn, voiceBtnIcon);
                    }
                };
                
                // Listen for input changes
                chatInput.addEventListener('input', updateButtonState);
                chatInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        if (this.currentButtonState === 'send') {
                            this.sendChatMessage(chatInput.value.trim());
                        }
                    }
                });
                
                // Setup voice recording press & hold
                this.setupVoiceRecording(voiceChatBtn, voiceBtnIcon, chatInput);
                
                // Initial state check
                updateButtonState();
            }
            
            /**
             * Set button state with visual feedback
             */
            setButtonState(state, button, icon) {
                // Remove all state classes
                button.classList.remove('state-mic', 'state-recording', 'state-send');
                
                // Add new state class and update icon
                switch (state) {
                    case 'mic':
                        button.classList.add('state-mic');
                        icon.className = 'bi bi-mic';
                        button.title = 'Click to start voice recording';
                        this.currentButtonState = 'mic';
                        break;
                        
                    case 'recording':
                        button.classList.add('state-recording');
                        icon.className = 'bi bi-record-circle';
                        button.title = 'Recording... Click to stop';
                        this.currentButtonState = 'recording';
                        break;
                        
                    case 'send':
                        button.classList.add('state-send');
                        icon.className = 'bi bi-send';
                        button.title = 'Send message';
                        this.currentButtonState = 'send';
                        break;
                }
                
                console.log('üé§ [VOICE] Button state changed to:', state);
            }
            
            /**
             * Setup voice recording click on/off functionality
             */
            setupVoiceRecording(voiceChatBtn, voiceBtnIcon, chatInput) {
                if (!this.voiceHandler || !this.voiceHandler.isApiSupported()) {
                    console.log('üé§ [VOICE] Voice recording setup skipped - not supported');
                    return;
                }
                
                let isRecording = false;
                let silenceTimeout = null;
                let accumulatedTranscript = '';
                
                // Toggle recording function
                const toggleRecording = async (e) => {
                    e.preventDefault();
                    
                    // If in send mode, send the message
                    if (this.currentButtonState === 'send') {
                        this.sendChatMessage(chatInput.value.trim());
                        return;
                    }
                    
                    // If not in mic mode, ignore
                    if (this.currentButtonState !== 'mic' && this.currentButtonState !== 'recording') {
                        return;
                    }
                    
                    if (!isRecording) {
                        // Start recording
                        await this.startVoiceRecording(voiceChatBtn, voiceBtnIcon, chatInput);
                        isRecording = true;
                    } else {
                        // Stop recording
                        await this.stopVoiceRecording(voiceChatBtn, voiceBtnIcon, chatInput);
                        isRecording = false;
                    }
                };
                
                // Setup silence timeout function
                const resetSilenceTimeout = () => {
                    if (silenceTimeout) {
                        clearTimeout(silenceTimeout);
                    }
                    
                    // Auto-stop after 10 seconds of silence
                    silenceTimeout = setTimeout(async () => {
                        if (isRecording) {
                            console.log('üé§ [VOICE] Auto-stopping after 10 seconds of silence');
                            await this.stopVoiceRecording(voiceChatBtn, voiceBtnIcon, chatInput);
                            isRecording = false;
                        }
                    }, 10000);
                };
                
                // Store timeout functions for access in other methods
                this.resetSilenceTimeout = resetSilenceTimeout;
                this.clearSilenceTimeout = () => {
                    if (silenceTimeout) {
                        clearTimeout(silenceTimeout);
                        silenceTimeout = null;
                    }
                };
                
                // Click event for toggle functionality
                voiceChatBtn.addEventListener('click', toggleRecording);
                
                // Prevent context menu on mobile
                voiceChatBtn.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                });
                
                console.log('‚úÖ [VOICE] Voice recording click on/off setup complete');
            }
            
            /**
             * Start voice recording
             */
            async startVoiceRecording(voiceChatBtn, voiceBtnIcon, chatInput) {
                // Only start recording if no text in input
                if (chatInput.value.trim().length > 0) {
                    console.log('üé§ [VOICE] Cannot start recording with text in input');
                    return;
                }
                
                console.log('üé§ [VOICE] Starting voice recording...');
                
                try {
                    // Setup voice handler callbacks
                    this.setupVoiceCallbacks(voiceChatBtn, voiceBtnIcon, chatInput);
                    
                    // Start recording
                    await this.voiceHandler.startRecognition();
                    
                    // Change to recording state
                    this.setButtonState('recording', voiceChatBtn, voiceBtnIcon);
                    this.updateVoiceStatus('Recording... Click again to stop');
                    
                    // Start silence timeout
                    if (this.resetSilenceTimeout) {
                        this.resetSilenceTimeout();
                    }
                    
                } catch (error) {
                    console.error('‚ùå [VOICE] Failed to start recording:', error);
                    this.updateVoiceStatus(`Error: ${error.message}`);
                    this.setButtonState('mic', voiceChatBtn, voiceBtnIcon);
                }
            }
            
            /**
             * Stop voice recording
             */
            async stopVoiceRecording(voiceChatBtn, voiceBtnIcon, chatInput) {
                console.log('üé§ [VOICE] Stopping voice recording...');
                
                try {
                    // Clear silence timeout
                    if (this.clearSilenceTimeout) {
                        this.clearSilenceTimeout();
                    }
                    
                    // Stop recording
                    this.voiceHandler.stopRecognition();
                    
                    // Show processing state
                    this.setButtonState('mic', voiceChatBtn, voiceBtnIcon);
                    this.updateVoiceStatus('Processing speech...');
                    
                } catch (error) {
                    console.error('‚ùå [VOICE] Failed to stop recording:', error);
                    this.updateVoiceStatus(`Error: ${error.message}`);
                    this.setButtonState('mic', voiceChatBtn, voiceBtnIcon);
                }
            }
            
            /**
             * Setup voice handler callbacks for recording session
             */
            setupVoiceCallbacks(voiceChatBtn, voiceBtnIcon, chatInput) {
                // Store partial transcript for continuous updates
                let partialTranscript = '';
                let finalTranscript = '';
                
                this.voiceHandler.onStart = () => {
                    console.log('üé§ [VOICE] Recording started');
                    this.updateVoiceStatus('Recording... Click again to stop');
                    partialTranscript = '';
                    finalTranscript = '';
                };
                
                this.voiceHandler.onEnd = () => {
                    console.log('üé§ [VOICE] Recording ended');
                    
                    // Clear silence timeout
                    if (this.clearSilenceTimeout) {
                        this.clearSilenceTimeout();
                    }
                    
                    // Process final accumulated transcript
                    if (finalTranscript.trim()) {
                        this.handleVoiceTranscript(finalTranscript.trim(), chatInput, voiceChatBtn, voiceBtnIcon);
                    } else {
                        console.log('üé§ [VOICE] No final transcript available');
                        this.updateVoiceStatus('No speech detected');
                        setTimeout(() => {
                            this.setButtonState('mic', voiceChatBtn, voiceBtnIcon);
                            this.updateVoiceStatus('');
                        }, 2000);
                    }
                };
                
                this.voiceHandler.onResult = (transcript, isFinal) => {
                    console.log('üé§ [VOICE] Transcript received:', { 
                        transcript, 
                        isFinal, 
                        length: transcript.length 
                    });
                    
                    if (isFinal) {
                        // Accumulate final results
                        if (transcript.trim()) {
                            finalTranscript += (finalTranscript ? ' ' : '') + transcript.trim();
                            console.log('üé§ [VOICE] Final transcript accumulated:', finalTranscript);
                        }
                        
                        // Reset silence timeout on final result
                        if (this.resetSilenceTimeout) {
                            this.resetSilenceTimeout();
                        }
                        
                    } else {
                        // Partial result - show preview in status
                        partialTranscript = transcript;
                        const displayText = (finalTranscript + ' ' + transcript).trim();
                        
                        if (displayText) {
                            this.updateVoiceStatus(`Recognizing: "${displayText}"`);
                        } else {
                            this.updateVoiceStatus('Recording... Click again to stop');
                        }
                        
                        // Reset silence timeout on partial result (speech detected)
                        if (transcript.trim() && this.resetSilenceTimeout) {
                            this.resetSilenceTimeout();
                        }
                    }
                };
                
                this.voiceHandler.onError = (error, message) => {
                    console.error('‚ùå [VOICE] Recognition error:', error);
                    this.updateVoiceStatus(`Error: ${message}`);
                    
                    // Clear silence timeout
                    if (this.clearSilenceTimeout) {
                        this.clearSilenceTimeout();
                    }
                    
                    // Reset to mic state after error
                    setTimeout(() => {
                        this.setButtonState('mic', voiceChatBtn, voiceBtnIcon);
                        this.updateVoiceStatus('');
                    }, 3000);
                };
            }
            
            /**
             * Handle voice transcript result with smart text processing
             */
            handleVoiceTranscript(transcript, chatInput, voiceChatBtn, voiceBtnIcon) {
                console.log('üé§ [VOICE] Handling transcript:', transcript);
                
                // Clean and process transcript
                const processedTranscript = this.processTranscript(transcript);
                
                if (!processedTranscript) {
                    console.log('üé§ [VOICE] Processed transcript is empty, ignoring');
                    this.updateVoiceStatus('No valid speech detected');
                    setTimeout(() => {
                        this.setButtonState('mic', voiceChatBtn, voiceBtnIcon);
                        this.updateVoiceStatus('');
                    }, 2000);
                    return;
                }
                
                // Check if there's existing text in input
                const existingText = chatInput.value.trim();
                let finalText = processedTranscript;
                
                if (existingText) {
                    // Append to existing text with space
                    finalText = existingText + ' ' + processedTranscript;
                    console.log('üé§ [VOICE] Appending to existing text:', { existingText, processedTranscript, finalText });
                }
                
                // Insert final text into input field
                chatInput.value = finalText;
                
                // Focus input field and set cursor at end
                chatInput.focus();
                chatInput.setSelectionRange(finalText.length, finalText.length);
                
                // Trigger input event to update button state
                chatInput.dispatchEvent(new Event('input', { bubbles: true }));
                
                // Show success feedback
                this.updateVoiceStatus('‚úì Voice message transcribed');
                
                // Clear success message after 2 seconds
                setTimeout(() => {
                    this.updateVoiceStatus('');
                }, 2000);
                
                console.log('‚úÖ [VOICE] Transcript processed and inserted:', { 
                    original: transcript, 
                    processed: processedTranscript, 
                    final: finalText 
                });
            }
            
            /**
             * Process and clean transcript text
             */
            processTranscript(transcript) {
                if (!transcript || typeof transcript !== 'string') {
                    return '';
                }
                
                // Clean transcript
                let processed = transcript.trim();
                
                // Capitalize first letter
                if (processed.length > 0) {
                    processed = processed.charAt(0).toUpperCase() + processed.slice(1);
                }
                
                // Add punctuation if missing
                if (processed.length > 0 && !/[.!?]$/.test(processed)) {
                    // Only add period for statements (not questions)
                    if (!/^(que|quoi|comment|pourquoi|o√π|quand|qui|how|what|where|when|why|who)/i.test(processed)) {
                        processed += '.';
                    } else {
                        processed += '?';
                    }
                }
                
                console.log('üé§ [VOICE] Transcript processed:', { original: transcript, processed });
                return processed;
            }
            
            /**
             * Update voice status indicator
             */
            updateVoiceStatus(message) {
                const voiceStatus = document.getElementById('voice-status');
                if (voiceStatus) {
                    voiceStatus.textContent = message;
                }
            }
            
            /**
             * Send chat message to AI trainer
             */
            async sendChatMessage(message) {
                if (!message) return;
                
                console.log('üí¨ [CHAT] Sending message:', message);
                
                const chatInput = document.getElementById('chat-input');
                const voiceChatBtn = document.getElementById('voice-chat-btn');
                const voiceBtnIcon = document.getElementById('voice-btn-icon');
                const chatMessages = document.getElementById('chat-messages');
                
                if (!chatMessages) {
                    console.error('‚ùå [CHAT] Chat messages container not found');
                    return;
                }
                
                try {
                    // Disable input and button during sending
                    if (chatInput) chatInput.disabled = true;
                    if (voiceChatBtn) voiceChatBtn.disabled = true;
                    
                    // Set button to loading state
                    this.setButtonState('send', voiceChatBtn, voiceBtnIcon);
                    if (voiceBtnIcon) voiceBtnIcon.className = 'bi bi-hourglass-split';
                    
                    // Add user message to chat
                    this.addChatMessage('user', message);
                    
                    // Clear input
                    if (chatInput) chatInput.value = '';
                    
                    // Show typing animation
                    this.showTypingAnimation();
                    
                    // Prepare chat request
                    const chatRequest = {
                        message: message,
                        context: {
                            training_id: this.sessionData.training_session.training_id,
                            learner_session_id: this.learnerSession.id,
                            current_slide_id: this.currentSlide?.id || null,
                            training_content: this.getCurrentSlideContent(),
                            learner_profile: this.getLearnerProfile(),
                            conversation_history: this.getChatHistory()
                        },
                        conversation_type: "general"
                    };
                    
                    console.log('üì§ [CHAT] Request payload:', chatRequest);
                    
                    // Call chat API
                    const response = await fetch('/api/chat', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(chatRequest)
                    });
                    
                    console.log('üì• [CHAT] Response status:', response.status);
                    
                    if (!response.ok) {
                        const errorData = await response.json();
                        console.error('‚ùå [CHAT] Error response:', errorData);
                        throw new Error(errorData.detail || 'Chat service temporarily unavailable');
                    }
                    
                    const chatResponse = await response.json();
                    console.log('‚úÖ [CHAT] Success response:', chatResponse);
                    
                    // Hide typing animation
                    this.hideTypingAnimation();
                    
                    // Add AI response to chat
                    this.addChatMessage('assistant', chatResponse.response, {
                        confidence: chatResponse.confidence_score,
                        suggested_actions: chatResponse.suggested_actions,
                        related_concepts: chatResponse.related_concepts,
                        conversation_type: chatResponse.conversation_type
                    });
                    
                } catch (error) {
                    console.error('‚ùå [CHAT] Error:', error);
                    
                    // Hide typing animation on error
                    this.hideTypingAnimation();
                    
                    // Show error message
                    this.addChatMessage('assistant', 
                        `I'm sorry, I encountered an error. Please try again. (${error.message})`,
                        { error: true }
                    );
                    
                } finally {
                    // Re-enable input and button
                    if (chatInput) {
                        chatInput.disabled = false;
                        chatInput.focus();
                    }
                    if (voiceChatBtn) voiceChatBtn.disabled = false;
                    
                    // Reset button state
                    this.setButtonState('mic', voiceChatBtn, voiceBtnIcon);
                }
            }
            
            /**
             * Get current slide content for context
             */
            getCurrentSlideContent() {
                if (this.currentSlide) {
                    return this.currentSlide.content || 'Current slide content';
                }
                return 'Training session content';
            }
            
            /**
             * Get learner profile for context
             */
            getLearnerProfile() {
                if (!this.learnerSession) {
                    return {};
                }
                
                return {
                    experience_level: this.learnerSession.experience_level,
                    learning_style: this.learnerSession.learning_style,
                    job_position: this.learnerSession.job_position,
                    activity_sector: this.learnerSession.activity_sector,
                    country: this.learnerSession.country,
                    language: this.learnerSession.language,
                    objectives: this.learnerSession.objectives,
                    training_duration: this.learnerSession.training_duration,
                    enriched_profile: this.learnerSession.enriched_profile
                };
            }
            
            /**
             * Get conversation history for context
             */
            getChatHistory() {
                const chatMessages = document.getElementById('chat-messages');
                if (!chatMessages) return [];
                
                const messages = [];
                const messageElements = chatMessages.querySelectorAll('.message');
                
                messageElements.forEach(msgEl => {
                    const role = msgEl.classList.contains('user') ? 'user' : 'assistant';
                    const contentEl = msgEl.querySelector('.message-content p');
                    if (contentEl) {
                        messages.push({
                            role: role,
                            content: contentEl.textContent.trim(),
                            timestamp: new Date().toISOString()
                        });
                    }
                });
                
                // Return last 10 messages to avoid context overflow
                return messages.slice(-10);
            }
            
            
            addChatMessage(role, content, metadata = {}) {
                const chatMessages = document.getElementById('chat-messages');
                
                const isUser = role === 'user';
                const messageClass = isUser ? 'justify-content-end' : '';
                const bubbleClass = isUser ? 'bg-primary text-white' : 'bg-light';
                
                // Add action type badge for contextual actions
                let actionTypeBadge = '';
                if (metadata.action_type) {
                    const badgeConfig = {
                        'comment': { class: 'bg-primary', icon: 'bi-chat-text', text: 'Comment' },
                        'quiz': { class: 'bg-secondary', icon: 'bi-question-circle', text: 'Quiz' },
                        'examples': { class: 'bg-info', icon: 'bi-lightbulb', text: 'Examples' },
                        'key-points': { class: 'bg-warning text-dark', icon: 'bi-star', text: 'Key Points' }
                    };
                    
                    const config = badgeConfig[metadata.action_type];
                    if (config) {
                        actionTypeBadge = `<div class="mt-1 mb-2"><span class="badge ${config.class}"><i class="${config.icon} me-1"></i>${config.text}</span></div>`;
                    }
                }

                const messageHtml = `
                    <div class="p-3">
                        <div class="message ${role} mb-3" ${metadata.action_type ? `data-action-type="${metadata.action_type}"` : ''}>
                            <div class="d-flex align-items-start ${messageClass}">
                                <div class="message-content">
                                    <div class="${bubbleClass} p-2 rounded">
                                        ${actionTypeBadge}
                                        <p class="mb-0 small">${content}</p>
                                        ${metadata.confidence ? `<div class="mt-1"><span class="badge bg-secondary">Confidence: ${Math.round(metadata.confidence * 100)}%</span></div>` : ''}
                                        ${metadata.suggested_actions && metadata.suggested_actions.length > 0 ? 
                                            `<div class="mt-2">
                                                <small class="text-muted">Suggestions:</small><br>
                                                ${metadata.suggested_actions.map(action => `<span class="badge bg-info me-1">${action}</span>`).join('')}
                                            </div>` : ''}
                                        ${metadata.related_concepts && metadata.related_concepts.length > 0 ? 
                                            `<div class="mt-2">
                                                <small class="text-muted">Related:</small><br>
                                                ${metadata.related_concepts.map(concept => `<span class="badge bg-success me-1">${concept}</span>`).join('')}
                                            </div>` : ''}
                                        ${metadata.error ? `<div class="mt-1"><span class="badge bg-danger">Error</span></div>` : ''}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                
                chatMessages.insertAdjacentHTML('beforeend', messageHtml);
                chatMessages.scrollTop = chatMessages.scrollHeight;
                
                console.log('üí¨ [CHAT] Message added:', { role, content: content.substring(0, 50) + '...', metadata });
            }
            
            showTypingAnimation() {
                const chatMessages = document.getElementById('chat-messages');
                
                const typingHtml = `
                    <div class="p-3" id="typing-indicator">
                        <div class="message assistant mb-3">
                            <div class="d-flex align-items-start">
                                <div class="message-content">
                                    <div class="bg-light p-2 rounded">
                                        <div class="typing-animation">
                                            <div class="typing-dot"></div>
                                            <div class="typing-dot"></div>
                                            <div class="typing-dot"></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                
                chatMessages.insertAdjacentHTML('beforeend', typingHtml);
                chatMessages.scrollTop = chatMessages.scrollHeight;
                
                console.log('üí≠ [CHAT] Typing animation shown');
            }
            
            hideTypingAnimation() {
                const typingIndicator = document.getElementById('typing-indicator');
                if (typingIndicator) {
                    typingIndicator.remove();
                    console.log('üí≠ [CHAT] Typing animation hidden');
                }
            }
            
            getChatHistory() {
                // R√©cup√©rer l'historique des messages du DOM
                const messages = [];
                const messageElements = document.querySelectorAll('#chat-messages .message');
                
                messageElements.forEach(element => {
                    const role = element.classList.contains('assistant') ? 'assistant' : 'user';
                    const content = element.querySelector('.message-content p')?.textContent || '';
                    const timestamp = element.querySelector('small')?.textContent || new Date().toISOString();
                    
                    if (content.trim()) {
                        messages.push({
                            role: role,
                            content: content,
                            timestamp: timestamp,
                            metadata: {}
                        });
                    }
                });
                
                console.log('üìù [CHAT] Chat history retrieved:', messages.length, 'messages');
                return messages.slice(-10); // Garder seulement les 10 derniers messages pour le contexte
            }
            
            setupContextualChatButtons() {
                const commentBtn = document.getElementById('comment-btn');
                const quizBtn = document.getElementById('quiz-btn');
                const examplesBtn = document.getElementById('examples-btn');
                const keyPointsBtn = document.getElementById('key-points-btn');
                
                if (commentBtn) {
                    commentBtn.addEventListener('click', () => this.handleContextualAction('comment'));
                    console.log('‚úÖ [CONTEXTUAL_CHAT] Comment button event listener added');
                }
                
                if (quizBtn) {
                    quizBtn.addEventListener('click', () => this.handleContextualAction('quiz'));
                    console.log('‚úÖ [CONTEXTUAL_CHAT] Quiz button event listener added');
                }
                
                if (examplesBtn) {
                    examplesBtn.addEventListener('click', () => this.handleContextualAction('examples'));
                    console.log('‚úÖ [CONTEXTUAL_CHAT] Examples button event listener added');
                }
                
                if (keyPointsBtn) {
                    keyPointsBtn.addEventListener('click', () => this.handleContextualAction('key-points'));
                    console.log('‚úÖ [CONTEXTUAL_CHAT] Key Points button event listener added');
                }
            }
            
            async handleContextualAction(actionType) {
                console.log(`üí¨ [CONTEXTUAL_CHAT] Handling ${actionType} action`);
                
                if (!this.currentSlideContent || !this.currentSlide) {
                    console.error('‚ùå [CONTEXTUAL_CHAT] No current slide content available');
                    this.addChatMessage('assistant', 
                        'I need slide content to provide this information. Please wait for the slide to load.',
                        { error: true }
                    );
                    return;
                }
                
                // Disable all contextual buttons during processing
                this.setContextualButtonsEnabled(false, actionType);
                
                // Afficher l'animation de r√©flexion de l'IA
                this.showTypingAnimation();
                
                try {
                    // Prepare request payload
                    const requestPayload = {
                        learner_session_id: this.learnerSession.id,
                        slide_content: this.currentSlideContent,
                        slide_title: this.currentSlide.title || 'Current Slide'
                    };
                    
                    console.log(`üì§ [CONTEXTUAL_CHAT] ${actionType} request payload:`, requestPayload);
                    
                    // Call the appropriate API endpoint
                    const apiEndpoint = `/api/chat/${actionType}`;
                    const response = await fetch(apiEndpoint, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(requestPayload)
                    });
                    
                    console.log(`üì• [CONTEXTUAL_CHAT] ${actionType} response status:`, response.status);
                    
                    if (!response.ok) {
                        const errorData = await response.json();
                        console.error(`‚ùå [CONTEXTUAL_CHAT] ${actionType} error response:`, errorData);
                        throw new Error(errorData.detail || `${actionType} service temporarily unavailable`);
                    }
                    
                    const chatResponse = await response.json();
                    console.log(`‚úÖ [CONTEXTUAL_CHAT] ${actionType} success response:`, chatResponse);
                    
                    // Supprimer l'animation de r√©flexion
                    this.hideTypingAnimation();
                    
                    // Add AI response to chat with appropriate metadata
                    this.addChatMessage('assistant', chatResponse.response, {
                        confidence: chatResponse.confidence_score,
                        suggested_actions: chatResponse.suggested_actions,
                        related_concepts: chatResponse.related_concepts,
                        action_type: actionType
                    });
                    
                } catch (error) {
                    console.error(`‚ùå [CONTEXTUAL_CHAT] ${actionType} error:`, error);
                    
                    // Supprimer l'animation de r√©flexion en cas d'erreur
                    this.hideTypingAnimation();
                    
                    // Add error message to chat
                    let errorMessage = `I'm sorry, I encountered an error while processing your ${actionType} request. Please try again.`;
                    if (actionType === 'comment') errorMessage = 'I cannot comment on this slide right now. Please try again later.';
                    else if (actionType === 'quiz') errorMessage = 'I cannot generate a quiz right now. Please try again later.';
                    else if (actionType === 'examples') errorMessage = 'I cannot provide examples right now. Please try again later.';
                    else if (actionType === 'key-points') errorMessage = 'I cannot extract key points right now. Please try again later.';
                    
                    this.addChatMessage('assistant', `${errorMessage} (${error.message})`, { error: true });
                    
                } finally {
                    // Re-enable contextual buttons
                    this.setContextualButtonsEnabled(true);
                }
            }
            
            setContextualButtonsEnabled(enabled, activeActionType = null) {
                const buttons = {
                    'comment': document.getElementById('comment-btn'),
                    'quiz': document.getElementById('quiz-btn'),
                    'examples': document.getElementById('examples-btn'),
                    'key-points': document.getElementById('key-points-btn')
                };
                
                Object.entries(buttons).forEach(([actionType, button]) => {
                    if (button) {
                        if (enabled) {
                            button.disabled = false;
                            // Restore original content
                            if (actionType === 'comment') button.innerHTML = '<i class="bi bi-chat-text me-1"></i>Comment';
                            else if (actionType === 'quiz') button.innerHTML = '<i class="bi bi-question-circle me-1"></i>Quiz';
                            else if (actionType === 'examples') button.innerHTML = '<i class="bi bi-lightbulb me-1"></i>Examples';
                            else if (actionType === 'key-points') button.innerHTML = '<i class="bi bi-star me-1"></i>Key Points';
                        } else {
                            if (actionType === activeActionType) {
                                button.disabled = true;
                                button.innerHTML = '<i class="bi bi-hourglass-split me-1"></i>Loading...';
                            } else {
                                button.disabled = true;
                            }
                        }
                    }
                });
            }
            
            updateBreadcrumb(slideData) {
                console.log('üß≠üß≠üß≠ [BREADCRUMB] === MISE √Ä JOUR BREADCRUMB ===');
                console.log('üß≠üß≠üß≠ [BREADCRUMB] slideData:', slideData);
                
                const breadcrumbElement = document.getElementById('progress-breadcrumb');
                if (!breadcrumbElement) {
                    console.log('‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è [BREADCRUMB] √âl√©ment progress-breadcrumb non trouv√©');
                    return;
                }
                
                // Extraire les informations de breadcrumb
                let breadcrumb = null;
                
                // Priorit√©: breadcrumb direct dans slideData
                if (slideData.breadcrumb) {
                    console.log('üß≠üß≠üß≠ [BREADCRUMB] BRANCHE 1: breadcrumb direct d√©tect√©');
                    breadcrumb = slideData.breadcrumb;
                } else if (slideData.data && slideData.data.breadcrumb) {
                    console.log('üß≠üß≠üß≠ [BREADCRUMB] BRANCHE 2: breadcrumb dans data d√©tect√©');
                    breadcrumb = slideData.data.breadcrumb;
                }
                
                console.log('üß≠üß≠üß≠ [BREADCRUMB] Breadcrumb extrait:', breadcrumb);
                
                // Valeurs par d√©faut si pas de breadcrumb
                if (!breadcrumb) {
                    console.log('üß≠üß≠üß≠ [BREADCRUMB] Utilisation valeurs par d√©faut');
                    breadcrumb = {
                        stage_name: "Formation",
                        module_name: "Module",
                        submodule_name: "Contenu"
                    };
                }
                
                // Construire le HTML du breadcrumb avec les styles appropri√©s
                const breadcrumbHtml = `
                    <span class="progress-text">
                        ${breadcrumb.stage_name} 
                        <i class="bi bi-chevron-right text-muted mx-1"></i> 
                        ${breadcrumb.module_name} 
                        <i class="bi bi-chevron-right text-muted mx-1"></i> 
                        <span class="current-module">${breadcrumb.submodule_name}</span>
                    </span>
                `;
                
                console.log('üß≠üß≠üß≠ [BREADCRUMB] HTML g√©n√©r√©:', breadcrumbHtml);
                breadcrumbElement.innerHTML = breadcrumbHtml;
                
                console.log('‚úÖ‚úÖ‚úÖ [BREADCRUMB] Breadcrumb mis √† jour avec succ√®s');
            }
            
            updateNavigationButtonStates() {
                const newPreviousBtn = document.getElementById('new-previous-btn');
                const newNextBtn = document.getElementById('new-next-btn');
                
                if (!this.currentSlide || !this.currentSlide.position) {
                    console.log('üîÑ [NAVIGATION] No position data available, keeping buttons enabled');
                    return;
                }
                
                const position = this.currentSlide.position;
                console.log('üîÑ [NAVIGATION] Updating button states:', position);
                
                // Update Previous button
                if (newPreviousBtn) {
                    if (position.has_previous === false) {
                        newPreviousBtn.disabled = true;
                        newPreviousBtn.classList.add('opacity-50');
                        console.log('üîÑ [NAVIGATION] Previous button disabled - at beginning');
                    } else {
                        newPreviousBtn.disabled = false;
                        newPreviousBtn.classList.remove('opacity-50');
                        console.log('üîÑ [NAVIGATION] Previous button enabled');
                    }
                }
                
                // Update Next button
                if (newNextBtn) {
                    if (position.has_next === false) {
                        newNextBtn.disabled = true;
                        newNextBtn.classList.add('opacity-50');
                        newNextBtn.innerHTML = '<i class="bi bi-check-circle me-1"></i>Complete';
                    } else {
                        newNextBtn.disabled = false;
                        newNextBtn.classList.remove('opacity-50');
                        newNextBtn.innerHTML = 'Next<i class="bi bi-chevron-right ms-1"></i>';
                        console.log('üîÑ [NAVIGATION] Next button enabled');
                    }
                }
                
                // Show progress info
                if (position.current_position && position.total_slides) {
                    console.log(`üîÑ [NAVIGATION] Progress: ${position.current_position}/${position.total_slides} slides`);
                }
            }
            
            setupSlideInteractionButtons() {
                // Cette fonction ne fait plus rien car les anciens boutons ont √©t√© supprim√©s
                // Tous les boutons sont maintenant g√©r√©s par setupNewNavigationButtons()
                console.log('‚úÖ [BUTTONS] setupSlideInteractionButtons - anciens boutons supprim√©s');
            }
            
            setupNewNavigationButtons() {
                // Connect new navigation buttons to same actions as old ones
                const newSimplifyBtn = document.getElementById('new-simplify-btn');
                const newMoreDetailsBtn = document.getElementById('new-more-details-btn');
                const newNextBtn = document.getElementById('new-next-btn');
                const newPreviousBtn = document.getElementById('new-previous-btn');
                
                if (newSimplifyBtn) {
                    newSimplifyBtn.addEventListener('click', () => this.simplifySlideContent());
                    console.log('‚úÖ [NEW_BUTTONS] New simplify button connected');
                }
                
                if (newMoreDetailsBtn) {
                    newMoreDetailsBtn.addEventListener('click', () => this.moreDetailsSlideContent());
                    console.log('‚úÖ [NEW_BUTTONS] New more details button connected');
                }
                
                if (newNextBtn) {
                    newNextBtn.addEventListener('click', () => this.navigateToNextSlide());
                    console.log('‚úÖ [NEW_BUTTONS] New next button connected');
                }
                
                if (newPreviousBtn) {
                    newPreviousBtn.addEventListener('click', () => this.navigateToPreviousSlide());
                    console.log('‚úÖ [NEW_BUTTONS] New previous button connected');
                }
            }
            
            async simplifySlideContent() {
                const newSimplifyBtn = document.getElementById('new-simplify-btn');
                const slideContentEl = document.getElementById('slide-content');
                
                if (!slideContentEl) {
                    console.error('‚ùå [SIMPLIFY] Slide content element not found');
                    return;
                }
                
                try {
                    console.log('üéØ [SIMPLIFY] Starting slide content simplification');
                    
                    // D√©sactiver le bouton pendant le traitement
                    if (newSimplifyBtn) {
                        newSimplifyBtn.disabled = true;
                        newSimplifyBtn.innerHTML = '<i class="bi bi-hourglass-split me-1"></i>Simplifying...';
                    }
                    
                    // Obtenir le contenu markdown actuel
                    const currentMarkdown = this.getCurrentSlideMarkdown();
                    if (!currentMarkdown) {
                        console.error('‚ùå [SIMPLIFY] No current slide content to simplify');
                        return;
                    }
                    
                    console.log('üìù [SIMPLIFY] Current content length:', currentMarkdown.length);
                    console.log('üìù [SIMPLIFY] Current content preview:', currentMarkdown.substring(0, 100) + '...');
                    
                    // Appeler l'API de simplification
                    const response = await fetch(`/api/slides/simplify/${this.learnerSession.id}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            current_content: currentMarkdown
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`API request failed: ${response.status} ${response.statusText}`);
                    }
                    
                    const result = await response.json();
                    console.log('‚úÖ [SIMPLIFY] API response received:', result);
                    
                    if (result.success && result.data.simplified_content) {
                        // Remplacer le contenu de la slide avec la version simplifi√©e
                        const simplifiedContent = result.data.simplified_content;
                        console.log('üìù [SIMPLIFY] Simplified content length:', simplifiedContent.length);
                        console.log('üìù [SIMPLIFY] Simplified content preview:', simplifiedContent.substring(0, 100) + '...');
                        
                        // Mettre √† jour l'affichage
                        slideContentEl.innerHTML = this.markdownToHtml(simplifiedContent);
                        
                        // Sauvegarder le nouveau contenu pour usage futur
                        this.currentSlideContent = simplifiedContent;
                        
                        console.log('‚úÖ [SIMPLIFY] Slide content simplified successfully');
                        
                        // Afficher un message de succ√®s temporaire
                        this.showSimplifySuccess(result.data);
                        
                    } else {
                        throw new Error('Invalid API response structure');
                    }
                    
                } catch (error) {
                    console.error('‚ùå [SIMPLIFY] Error simplifying slide content:', error);
                    
                    // Afficher une erreur √† l'utilisateur
                    this.showSimplifyError(error.message);
                    
                } finally {
                    // R√©activer le bouton
                    if (newSimplifyBtn) {
                        newSimplifyBtn.disabled = false;
                        newSimplifyBtn.innerHTML = '<i class="bi bi-arrow-down-circle me-1"></i>Simplify';
                    }
                }
            }
            
            getCurrentSlideMarkdown() {
                // Pour l'instant, nous devons reconstruire le markdown √† partir du HTML affich√©
                // Dans une impl√©mentation future, nous pourrions stocker le markdown original
                return this.currentSlideContent || 'No slide content available';
            }
            
            showSimplifySuccess(data) {
                // Alerts supprim√©s - fonction d√©sactiv√©e
                console.log('üéØ [SIMPLIFY] Content simplified successfully:', data);
            }
            
            showSimplifyError(errorMessage) {
                // Alerts supprim√©s - fonction d√©sactiv√©e
                console.error('‚ùå [SIMPLIFY] Error:', errorMessage);
            }
            
            async moreDetailsSlideContent() {
                const newMoreDetailsBtn = document.getElementById('new-more-details-btn');
                const slideContentEl = document.getElementById('slide-content');
                
                if (!slideContentEl) {
                    console.error('‚ùå [MORE_DETAILS] Slide content element not found');
                    return;
                }
                
                try {
                    console.log('üéØ [MORE_DETAILS] Starting slide content enhancement');
                    
                    // D√©sactiver le bouton pendant le traitement
                    if (newMoreDetailsBtn) {
                        newMoreDetailsBtn.disabled = true;
                        newMoreDetailsBtn.innerHTML = '<i class="bi bi-hourglass-split me-1"></i>Adding Details...';
                    }
                    
                    // Obtenir le contenu markdown actuel
                    const currentMarkdown = this.getCurrentSlideMarkdown();
                    if (!currentMarkdown) {
                        console.error('‚ùå [MORE_DETAILS] No current slide content to enhance');
                        return;
                    }
                    
                    console.log('üìù [MORE_DETAILS] Current content length:', currentMarkdown.length);
                    console.log('üìù [MORE_DETAILS] Current content preview:', currentMarkdown.substring(0, 100) + '...');
                    
                    // Appeler l'API d'approfondissement
                    const response = await fetch(`/api/slides/more-details/${this.learnerSession.id}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            current_content: currentMarkdown
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`API request failed: ${response.status} ${response.statusText}`);
                    }
                    
                    const result = await response.json();
                    console.log('‚úÖ [MORE_DETAILS] API response received:', result);
                    
                    if (result.success && result.data.detailed_content) {
                        // Remplacer le contenu de la slide avec la version approfondie
                        const detailedContent = result.data.detailed_content;
                        console.log('üìù [MORE_DETAILS] Enhanced content length:', detailedContent.length);
                        console.log('üìù [MORE_DETAILS] Enhanced content preview:', detailedContent.substring(0, 100) + '...');
                        
                        // Mettre √† jour l'affichage
                        slideContentEl.innerHTML = this.markdownToHtml(detailedContent);
                        
                        // Sauvegarder le nouveau contenu pour usage futur
                        this.currentSlideContent = detailedContent;
                        
                        console.log('‚úÖ [MORE_DETAILS] Slide content enhanced successfully');
                        
                        // Afficher un message de succ√®s temporaire
                        this.showMoreDetailsSuccess(result.data);
                        
                    } else {
                        throw new Error('Invalid API response structure');
                    }
                    
                } catch (error) {
                    console.error('‚ùå [MORE_DETAILS] Error enhancing slide content:', error);
                    
                    // Afficher une erreur √† l'utilisateur
                    this.showMoreDetailsError(error.message);
                    
                } finally {
                    // R√©activer le bouton
                    if (newMoreDetailsBtn) {
                        newMoreDetailsBtn.disabled = false;
                        newMoreDetailsBtn.innerHTML = '<i class="bi bi-arrow-up-circle me-1"></i>Deepen';
                    }
                }
            }
            
            showMoreDetailsSuccess(data) {
                // Alerts supprim√©s - fonction d√©sactiv√©e
                console.log('üéØ [MORE_DETAILS] Content enhanced successfully:', data);
            }
            
            showMoreDetailsError(errorMessage) {
                // Alerts supprim√©s - fonction d√©sactiv√©e
                console.error('‚ùå [MORE_DETAILS] Error:', errorMessage);
            }
            
            async navigateToNextSlide() {
                const newNextBtn = document.getElementById('new-next-btn');
                
                if (!this.currentSlide) {
                    console.error('‚ùå [NAVIGATION] No current slide data available');
                    this.showNavigationError('No current slide information available');
                    return;
                }
                
                try {
                    console.log('üéØ [NAVIGATION] Starting navigation to next slide');
                    
                    // D√©sactiver le bouton pendant le traitement
                    if (newNextBtn) {
                        newNextBtn.disabled = true;
                        newNextBtn.innerHTML = '<i class="bi bi-hourglass-split me-1"></i>Loading...';
                    }
                    
                    // Obtenir l'ID de la slide actuelle
                    const currentSlideId = this.currentSlide.slide_id || this.currentSlide.id;
                    if (!currentSlideId) {
                        console.error('‚ùå [NAVIGATION] No current slide ID found');
                        this.showNavigationError('Could not determine current slide');
                        return;
                    }
                    
                    console.log('üìù [NAVIGATION] Current slide ID:', currentSlideId);
                    console.log('üìù [NAVIGATION] Learner session ID:', this.learnerSession.id);
                    
                    // Appeler l'API de navigation
                    const response = await fetch(`/api/slides/next/${this.learnerSession.id}/${currentSlideId}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    console.log('üì• [NAVIGATION] Response status:', response.status);
                    
                    if (!response.ok) {
                        const errorData = await response.json();
                        console.error('‚ùå [NAVIGATION] Error response:', errorData);
                        
                        // Check if we've reached the end
                        if (response.status === 404 || errorData.message?.includes('end')) {
                            this.showNavigationComplete();
                            return;
                        }
                        
                        throw new Error(errorData.detail || 'Failed to navigate to next slide');
                    }
                    
                    const navigationResult = await response.json();
                    console.log('‚úÖ [NAVIGATION] Success response:', navigationResult);
                    
                    // Check if there's no next slide
                    if (!navigationResult.success || !navigationResult.data.has_next) {
                        this.showNavigationComplete();
                        return;
                    }
                    
                    // Display the next slide
                    this.displaySlideContent(navigationResult.data);
                    this.showNavigationSuccess(navigationResult.data);
                    
                } catch (error) {
                    console.error('‚ùå [NAVIGATION] Error:', error);
                    this.showNavigationError(error.message);
                    
                } finally {
                    // R√©activer le bouton
                    if (newNextBtn) {
                        newNextBtn.disabled = false;
                        newNextBtn.innerHTML = 'Next<i class="bi bi-chevron-right ms-1"></i>';
                    }
                }
            }
            
            showNavigationSuccess(slideData) {
                // Alerts supprim√©s - fonction d√©sactiv√©e
                console.log('üéØ [NAVIGATION] Navigation successful:', slideData.title || 'Next slide');
            }
            
            showNavigationComplete() {
                // Alerts supprim√©s - garde seulement la logique des boutons
                console.log('üéØ [NAVIGATION] Training complete!');
                
                // Disable the Next button
                const newNextBtn = document.getElementById('new-next-btn');
                if (newNextBtn) {
                    newNextBtn.disabled = true;
                    newNextBtn.innerHTML = '<i class="bi bi-check-circle me-1"></i>Complete';
                }
            }
            
            showNavigationError(errorMessage) {
                // Alerts supprim√©s - fonction d√©sactiv√©e
                console.error('‚ùå [NAVIGATION] Error:', errorMessage);
            }
            
            async navigateToPreviousSlide() {
                const newPreviousBtn = document.getElementById('new-previous-btn');
                
                if (!this.currentSlide) {
                    console.error('‚ùå [NAVIGATION] No current slide data available');
                    this.showNavigationError('No current slide information available');
                    return;
                }
                
                try {
                    console.log('üéØ [NAVIGATION] Starting navigation to previous slide');
                    
                    // D√©sactiver le bouton pendant le traitement
                    if (newPreviousBtn) {
                        newPreviousBtn.disabled = true;
                        newPreviousBtn.innerHTML = '<i class="bi bi-hourglass-split me-1"></i>Loading...';
                    }
                    
                    // Obtenir l'ID de la slide actuelle
                    const currentSlideId = this.currentSlide.slide_id || this.currentSlide.id;
                    if (!currentSlideId) {
                        console.error('‚ùå [NAVIGATION] No current slide ID found');
                        this.showNavigationError('Could not determine current slide');
                        return;
                    }
                    
                    console.log('üìù [NAVIGATION] Current slide ID:', currentSlideId);
                    console.log('üìù [NAVIGATION] Learner session ID:', this.learnerSession.id);
                    
                    // Appeler l'API de navigation pr√©c√©dente
                    const response = await fetch(`/api/slides/previous/${this.learnerSession.id}/${currentSlideId}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    console.log('üì• [NAVIGATION] Response status:', response.status);
                    
                    if (!response.ok) {
                        const errorData = await response.json();
                        console.error('‚ùå [NAVIGATION] Error response:', errorData);
                        
                        // Check if we've reached the beginning
                        if (response.status === 404 || errorData.message?.includes('beginning')) {
                            this.showNavigationBeginning();
                            return;
                        }
                        
                        throw new Error(errorData.detail || 'Failed to navigate to previous slide');
                    }
                    
                    const navigationResult = await response.json();
                    console.log('‚úÖ [NAVIGATION] Success response:', navigationResult);
                    
                    // Check if there's no previous slide
                    if (!navigationResult.success || !navigationResult.data.has_previous) {
                        this.showNavigationBeginning();
                        return;
                    }
                    
                    // Display the previous slide
                    this.displaySlideContent(navigationResult.data);
                    this.showPreviousNavigationSuccess(navigationResult.data);
                    
                } catch (error) {
                    console.error('‚ùå [NAVIGATION] Error:', error);
                    this.showNavigationError(error.message);
                    
                } finally {
                    // R√©activer le bouton
                    if (newPreviousBtn) {
                        newPreviousBtn.disabled = false;
                        newPreviousBtn.innerHTML = '<i class="bi bi-chevron-left me-1"></i>Previous';
                    }
                }
            }
            
            showPreviousNavigationSuccess(slideData) {
                // Alerts supprim√©s - fonction d√©sactiv√©e
                console.log('üéØ [NAVIGATION] Previous navigation successful:', slideData.title || 'Previous slide');
            }
            
            showNavigationBeginning() {
                // Alerts supprim√©s - garde seulement la logique des boutons
                console.log('üéØ [NAVIGATION] At the beginning!');
                
                // Disable the Previous button
                const newPreviousBtn = document.getElementById('new-previous-btn');
                if (newPreviousBtn) {
                    newPreviousBtn.disabled = true;
                    newPreviousBtn.innerHTML = '<i class="bi bi-stop-circle me-1"></i>Beginning';
                }
                
                // R√©activer le bouton apr√®s 5 secondes
                setTimeout(() => {
                    if (newPreviousBtn && this.currentSlide && (this.currentSlide.position?.has_previous !== false)) {
                        newPreviousBtn.disabled = false;
                        newPreviousBtn.innerHTML = '<i class="bi bi-chevron-left me-1"></i>Previous';
                    }
                }, 5000);
            }
            
            // ============================================================================
            // LIVE VOICE FUNCTIONALITY
            // ============================================================================
            
            setupLiveVoiceFunctionality() {
                const liveVoiceBtn = document.getElementById('live-voice-btn');
                
                if (liveVoiceBtn) {
                    liveVoiceBtn.addEventListener('click', () => this.toggleLiveVoice());
                    console.log('‚úÖ [LIVE_VOICE] Live voice button event listener added');
                } else {
                    console.warn('‚ö†Ô∏è [LIVE_VOICE] Live voice button not found');
                }
                
                // Initialize Live Voice state
                this.liveVoiceState = {
                    isActive: false,
                    isConnecting: false,
                    websocket: null,
                    mediaRecorder: null,
                    audioContext: null,
                    microphone: null,
                    audioChunks: []
                };
            }
            
            async toggleLiveVoice() {
                console.log('üéôÔ∏è [LIVE_VOICE] Toggle live voice, current state:', this.liveVoiceState.isActive);
                
                if (this.liveVoiceState.isActive) {
                    await this.stopLiveVoice();
                } else {
                    await this.startLiveVoice();
                }
            }
            
            async startLiveVoice() {
                const liveBtn = document.getElementById('live-voice-btn');
                const liveIcon = document.getElementById('live-voice-icon');
                const liveText = document.getElementById('live-voice-text');
                const liveStatus = document.getElementById('live-status');
                
                try {
                    console.log('üöÄ [LIVE_VOICE] Starting live voice session...');
                    
                    // Update UI to connecting state
                    this.liveVoiceState.isConnecting = true;
                    if (liveBtn) liveBtn.disabled = true;
                    if (liveIcon) liveIcon.className = 'bi bi-hourglass-split me-1';
                    if (liveText) liveText.textContent = 'Connecting...';
                    if (liveStatus) liveStatus.textContent = 'Connecting to Live API...';
                    
                    // Request microphone access
                    console.log('üé§ [LIVE_VOICE] Requesting microphone access...');
                    
                    // Check if we're in a secure context for microphone access
                    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                        throw new Error('Microphone access not available. Please use HTTPS or localhost.');
                    }
                    
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            sampleRate: 16000,
                            channelCount: 1,
                            echoCancellation: true,
                            noiseSuppression: true
                        } 
                    });
                    
                    console.log('‚úÖ [LIVE_VOICE] Microphone access granted');
                    
                    // Initialize Audio Context
                    this.liveVoiceState.audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });
                    this.liveVoiceState.microphone = this.liveVoiceState.audioContext.createMediaStreamSource(stream);
                    
                    // Connect to WebSocket
                    await this.connectLiveWebSocket();
                    
                    // Setup MediaRecorder for audio capture
                    this.setupAudioRecording(stream);
                    
                    // Update state
                    this.liveVoiceState.isActive = true;
                    this.liveVoiceState.isConnecting = false;
                    
                    // Update UI to active state
                    if (liveBtn) {
                        liveBtn.disabled = false;
                        liveBtn.className = 'btn btn-success w-100 btn-sm';
                    }
                    if (liveIcon) liveIcon.className = 'bi bi-mic-fill me-1';
                    if (liveText) liveText.textContent = 'Live Voice Active';
                    if (liveStatus) liveStatus.textContent = 'Speak now - AI is listening';
                    
                    console.log('‚úÖ [LIVE_VOICE] Live voice session started successfully');
                    
                } catch (error) {
                    console.error('‚ùå [LIVE_VOICE] Error starting live voice:', error);
                    
                    // Reset state
                    this.liveVoiceState.isConnecting = false;
                    this.liveVoiceState.isActive = false;
                    
                    // Reset UI
                    if (liveBtn) {
                        liveBtn.disabled = false;
                        liveBtn.className = 'btn btn-danger w-100 btn-sm';
                    }
                    if (liveIcon) liveIcon.className = 'bi bi-mic me-1';
                    if (liveText) liveText.textContent = 'Start Live Voice';
                    if (liveStatus) liveStatus.textContent = `Error: ${error.message}`;
                    
                    // Show error in chat
                    this.addChatMessage('assistant', 
                        `I couldn't start the live voice session. Error: ${error.message}. Please check your microphone permissions and try again.`,
                        { error: true }
                    );
                }
            }
            
            async connectLiveWebSocket() {
                return new Promise((resolve, reject) => {
                    console.log('üîó [LIVE_VOICE] Connecting to WebSocket...');
                    
                    // Pour localhost, utiliser toujours ws:// m√™me si la page est en http://
                    const wsProtocol = (window.location.protocol === 'https:' && !window.location.hostname.includes('localhost')) ? 'wss:' : 'ws:';
                    const wsUrl = `${wsProtocol}//${window.location.host}/ws/live/${this.learnerSession.id}`;
                    
                    console.log('üîó [LIVE_VOICE] Protocol detection:', {
                        'window.location.protocol': window.location.protocol,
                        'window.location.hostname': window.location.hostname,
                        'wsProtocol': wsProtocol,
                        'wsUrl': wsUrl
                    });
                    
                    console.log('üîó [LIVE_VOICE] WebSocket URL:', wsUrl);
                    
                    this.liveVoiceState.websocket = new WebSocket(wsUrl);
                    
                    this.liveVoiceState.websocket.onopen = (event) => {
                        console.log('‚úÖ [LIVE_VOICE] WebSocket connected');
                        resolve();
                    };
                    
                    this.liveVoiceState.websocket.onmessage = (event) => {
                        this.handleLiveWebSocketMessage(event);
                    };
                    
                    this.liveVoiceState.websocket.onerror = (error) => {
                        console.error('‚ùå [LIVE_VOICE] WebSocket error:', error);
                        reject(new Error('WebSocket connection failed'));
                    };
                    
                    this.liveVoiceState.websocket.onclose = (event) => {
                        console.log('üîå [LIVE_VOICE] WebSocket closed:', event.code, event.reason);
                        if (this.liveVoiceState.isActive) {
                            this.handleLiveDisconnection();
                        }
                    };
                });
            }
            
            setupAudioRecording(stream) {
                console.log('üéµ [LIVE_VOICE] Setting up audio recording...');
                
                // Create MediaRecorder with best supported format
                let options = { mimeType: 'audio/webm;codecs=opus' };
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    options = { mimeType: 'audio/ogg;codecs=opus' };
                    if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                        options = { mimeType: 'audio/webm' };
                        if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                            options = {}; // Use default
                        }
                    }
                }
                
                console.log('üéµ [LIVE_VOICE] Using MediaRecorder format:', options.mimeType || 'default');
                this.liveVoiceState.mediaRecorder = new MediaRecorder(stream, options);
                this.liveVoiceState.currentMimeType = options.mimeType || 'audio/webm';
                
                this.liveVoiceState.audioChunks = [];
                
                this.liveVoiceState.mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        console.log('üéµ [LIVE_VOICE] Audio chunk received:', event.data.size, 'bytes');
                        this.liveVoiceState.audioChunks.push(event.data);
                        this.processAudioChunk(event.data);
                    }
                };
                
                this.liveVoiceState.mediaRecorder.onstop = () => {
                    console.log('üéµ [LIVE_VOICE] MediaRecorder stopped');
                };
                
                // Start recording in chunks (send every 1 second)
                this.liveVoiceState.mediaRecorder.start(1000);
                console.log('‚úÖ [LIVE_VOICE] Audio recording started');
            }
            
            async processAudioChunk(audioBlob) {
                try {
                    console.log('üéµ [LIVE_VOICE] Processing audio chunk:', audioBlob.size, 'bytes');
                    
                    // Convert blob to ArrayBuffer
                    const arrayBuffer = await audioBlob.arrayBuffer();
                    const base64Audio = this.arrayBufferToBase64(arrayBuffer);
                    
                    // Send audio via WebSocket
                    if (this.liveVoiceState.websocket && this.liveVoiceState.websocket.readyState === WebSocket.OPEN) {
                        const message = {
                            type: 'audio',
                            data: base64Audio,
                            mime_type: this.liveVoiceState.currentMimeType || 'audio/webm'
                        };
                        
                        this.liveVoiceState.websocket.send(JSON.stringify(message));
                        console.log('üì§ [LIVE_VOICE] Audio chunk sent via WebSocket');
                    } else {
                        console.warn('‚ö†Ô∏è [LIVE_VOICE] WebSocket not ready, skipping audio chunk');
                    }
                    
                } catch (error) {
                    console.error('‚ùå [LIVE_VOICE] Error processing audio chunk:', error);
                }
            }
            
            arrayBufferToBase64(buffer) {
                const bytes = new Uint8Array(buffer);
                let binary = '';
                for (let i = 0; i < bytes.byteLength; i++) {
                    binary += String.fromCharCode(bytes[i]);
                }
                return btoa(binary);
            }
            
            base64ToArrayBuffer(base64) {
                const binaryString = atob(base64);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return bytes.buffer;
            }
            
            handleLiveWebSocketMessage(event) {
                try {
                    const message = JSON.parse(event.data);
                    console.log('üì• [LIVE_VOICE] WebSocket message received:', message.type);
                    
                    switch (message.type) {
                        case 'session_started':
                            console.log('‚úÖ [LIVE_VOICE] Live session started:', message.live_session_id);
                            this.addChatMessage('assistant', 
                                'Live voice session started! I can now hear you speaking.',
                                { action_type: 'live-session' }
                            );
                            break;
                            
                        case 'audio_response':
                            console.log('üîä [LIVE_VOICE] Audio response received');
                            // Only process if we have actual content or if not throttled
                            if (message.metadata && message.metadata.throttled) {
                                console.log('‚è∏Ô∏è [LIVE_VOICE] Response throttled, skipping...');
                                break;
                            }
                            
                            // Check for text-only mode (mock responses)
                            const isTextOnly = message.metadata && message.metadata.text_only;
                            const hasText = message.metadata && message.metadata.text_transcript;
                            const hasAudio = message.data && message.data.length > 0;
                            
                            if (isTextOnly && hasText) {
                                console.log('üìù [LIVE_VOICE] Text-only response received (mock mode)');
                                this.addChatMessage('assistant', 
                                    message.metadata.text_transcript,
                                    { action_type: 'live-voice', mock: true }
                                );
                            } else if (hasAudio || hasText) {
                                this.playAudioResponse(message.data, message.metadata);
                            } else {
                                console.log('üîá [LIVE_VOICE] Empty response, skipping...');
                            }
                            break;
                            
                        case 'error':
                            console.error('‚ùå [LIVE_VOICE] WebSocket error:', message.message);
                            this.addChatMessage('assistant', 
                                `Live voice error: ${message.message}`,
                                { error: true }
                            );
                            break;
                            
                        case 'pong':
                            console.log('üèì [LIVE_VOICE] Pong received');
                            break;
                            
                        default:
                            console.log('‚ùì [LIVE_VOICE] Unknown message type:', message.type);
                    }
                    
                } catch (error) {
                    console.error('‚ùå [LIVE_VOICE] Error parsing WebSocket message:', error);
                }
            }
            
            async playAudioResponse(base64Audio, metadata) {
                try {
                    console.log('üîä [LIVE_VOICE] Playing audio response...');
                    console.log('üîä [LIVE_VOICE] Audio data length:', base64Audio ? base64Audio.length : 'null');
                    console.log('üîä [LIVE_VOICE] Metadata:', metadata);
                    
                    // Check if this is mock mode
                    const isMockMode = metadata && metadata.processing_metadata && metadata.processing_metadata.mock === true;
                    
                    if (isMockMode) {
                        console.log('üé≠ [LIVE_VOICE] Mock mode detected - skipping audio playback');
                        
                        // In mock mode, just show the text transcript
                        if (metadata && metadata.text_transcript) {
                            this.addChatMessage('assistant', 
                                metadata.text_transcript,
                                { action_type: 'live-voice', mock: true }
                            );
                        }
                        
                        // Play a simple confirmation sound instead of trying to decode mock audio
                        this.playMockAudioConfirmation();
                        return;
                    }
                    
                    // Check if we have valid audio data
                    if (!base64Audio || base64Audio.length === 0) {
                        console.warn('‚ö†Ô∏è [LIVE_VOICE] No audio data received');
                        // If we have text and it's mock mode, show it normally (not as error)
                        if (metadata && metadata.text_transcript) {
                            const isTextOnlyMode = metadata.text_only || metadata.mock;
                            if (isTextOnlyMode) {
                                this.addChatMessage('assistant', 
                                    metadata.text_transcript,
                                    { action_type: 'live-voice', mock: true }
                                );
                            } else {
                                this.addChatMessage('assistant', 
                                    `[No audio data] ${metadata.text_transcript}`,
                                    { error: true }
                                );
                            }
                        }
                        return;
                    }
                    
                    // Real audio mode - try to decode and play actual audio
                    const audioBuffer = this.base64ToArrayBuffer(base64Audio);
                    
                    // Create audio context if needed
                    if (!this.liveVoiceState.audioContext) {
                        this.liveVoiceState.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    
                    // Try to decode and play audio with fallback
                    try {
                        const decodedAudio = await this.liveVoiceState.audioContext.decodeAudioData(audioBuffer.slice(0));
                        const source = this.liveVoiceState.audioContext.createBufferSource();
                        source.buffer = decodedAudio;
                        source.connect(this.liveVoiceState.audioContext.destination);
                        source.start();
                        
                        console.log('‚úÖ [LIVE_VOICE] Audio response playing');
                    } catch (decodeError) {
                        console.warn('‚ö†Ô∏è [LIVE_VOICE] WebAudio decode failed, trying HTML5 audio:', decodeError);
                        
                        // Fallback to HTML5 Audio
                        const audioBlob = new Blob([audioBuffer], { type: 'audio/ogg' });
                        const audioUrl = URL.createObjectURL(audioBlob);
                        const audio = new Audio(audioUrl);
                        
                        audio.onended = () => URL.revokeObjectURL(audioUrl);
                        audio.onerror = (audioError) => {
                            console.error('‚ùå [LIVE_VOICE] HTML5 audio also failed:', audioError);
                            // Don't throw error, just fallback to text
                            console.log('üîÑ [LIVE_VOICE] Falling back to text-only response');
                        };
                        
                        await audio.play();
                        console.log('‚úÖ [LIVE_VOICE] HTML5 audio playing');
                    }
                    
                    // Add transcript to chat if available
                    if (metadata && metadata.text_transcript) {
                        this.addChatMessage('assistant', 
                            metadata.text_transcript,
                            { action_type: 'live-voice' }
                        );
                    }
                    
                } catch (error) {
                    console.error('‚ùå [LIVE_VOICE] Error playing audio response:', error);
                    
                    // Fallback: show text response if audio fails
                    if (metadata && metadata.text_transcript) {
                        this.addChatMessage('assistant', 
                            metadata.text_transcript, // Remove error prefix since it's expected
                            { action_type: 'live-voice' }
                        );
                    } else {
                        this.addChatMessage('assistant', 
                            'Audio response received but could not be played.',
                            { action_type: 'live-voice' }
                        );
                    }
                }
            }
            
            playMockAudioConfirmation() {
                try {
                    console.log('üé≠ [LIVE_VOICE] Playing mock audio confirmation beep');
                    
                    // Create audio context if needed
                    if (!this.liveVoiceState.audioContext) {
                        this.liveVoiceState.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    
                    // Generate a simple confirmation beep (1000Hz for 200ms)
                    const audioCtx = this.liveVoiceState.audioContext;
                    const oscillator = audioCtx.createOscillator();
                    const gainNode = audioCtx.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioCtx.destination);
                    
                    oscillator.frequency.value = 1000; // 1kHz beep
                    gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime); // Low volume
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.2); // Fade out
                    
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.2); // 200ms beep
                    
                    console.log('‚úÖ [LIVE_VOICE] Mock confirmation beep played');
                    
                } catch (error) {
                    console.warn('‚ö†Ô∏è [LIVE_VOICE] Could not play mock confirmation beep:', error);
                    // Not a critical error, continue silently
                }
            }
            
            async stopLiveVoice() {
                console.log('üõë [LIVE_VOICE] Stopping live voice session...');
                
                const liveBtn = document.getElementById('live-voice-btn');
                const liveIcon = document.getElementById('live-voice-icon');
                const liveText = document.getElementById('live-voice-text');
                const liveStatus = document.getElementById('live-status');
                
                try {
                    // Stop MediaRecorder
                    if (this.liveVoiceState.mediaRecorder && this.liveVoiceState.mediaRecorder.state !== 'inactive') {
                        this.liveVoiceState.mediaRecorder.stop();
                    }
                    
                    // Close WebSocket
                    if (this.liveVoiceState.websocket) {
                        this.liveVoiceState.websocket.send(JSON.stringify({ type: 'close' }));
                        this.liveVoiceState.websocket.close();
                        this.liveVoiceState.websocket = null;
                    }
                    
                    // Stop microphone
                    if (this.liveVoiceState.microphone && this.liveVoiceState.microphone.mediaStream) {
                        this.liveVoiceState.microphone.mediaStream.getTracks().forEach(track => track.stop());
                    }
                    
                    // Close audio context
                    if (this.liveVoiceState.audioContext) {
                        await this.liveVoiceState.audioContext.close();
                        this.liveVoiceState.audioContext = null;
                    }
                    
                    // Reset state
                    this.liveVoiceState.isActive = false;
                    this.liveVoiceState.isConnecting = false;
                    this.liveVoiceState.mediaRecorder = null;
                    this.liveVoiceState.microphone = null;
                    this.liveVoiceState.audioChunks = [];
                    
                    // Reset UI
                    if (liveBtn) {
                        liveBtn.disabled = false;
                        liveBtn.className = 'btn btn-danger w-100 btn-sm';
                    }
                    if (liveIcon) liveIcon.className = 'bi bi-mic me-1';
                    if (liveText) liveText.textContent = 'Start Live Voice';
                    if (liveStatus) liveStatus.textContent = 'Click to talk with AI trainer';
                    
                    console.log('‚úÖ [LIVE_VOICE] Live voice session stopped successfully');
                    
                    this.addChatMessage('assistant', 
                        'Live voice session ended. Click the Live Voice button to start a new session.',
                        { action_type: 'live-session' }
                    );
                    
                } catch (error) {
                    console.error('‚ùå [LIVE_VOICE] Error stopping live voice:', error);
                }
            }
            
            handleLiveDisconnection() {
                console.log('üîå [LIVE_VOICE] Handling live disconnection...');
                
                // Force stop live voice
                this.stopLiveVoice();
                
                this.addChatMessage('assistant', 
                    'Live voice session was disconnected unexpectedly. You can start a new session anytime.',
                    { error: true }
                );
            }
            
            showError(message) {
                this.container.innerHTML = `
                    <div class="row">
                        <div class="col-12">
                            <div class="alert alert-danger" role="alert">
                                <h4 class="alert-heading">
                                    <i class="bi bi-exclamation-triangle me-2"></i>Error
                                </h4>
                                <p>${message}</p>
                                <hr>
                                <div class="mb-0">
                                    <button class="btn btn-outline-danger" onclick="location.reload()">
                                        <i class="bi bi-arrow-clockwise me-1"></i>Retry
                                    </button>
                                    <button class="btn btn-outline-secondary" onclick="history.back()">
                                        <i class="bi bi-arrow-left me-1"></i>Go Back
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }
        }
        
        // Initialize the application when page loads
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üåü Training page loaded, initializing app...');
            new TrainingApp();
        });
    </script>
</body>
</html>