<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FIA v3.0 - Personal Training Plan</title>
    
    <!-- Bootstrap 5.3.2 -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css" rel="stylesheet">
    
    <!-- Custom styles -->
    <link href="../src/styles/main.css" rel="stylesheet">
    
    <style>
        /* KISS: Simple markdown styling */
        .slide-content h1, .slide-content h2, .slide-content h3 {
            color: #0d6efd;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
        }
        .slide-content h1 { font-size: 1.75rem; }
        .slide-content h2 { font-size: 1.5rem; }
        .slide-content h3 { font-size: 1.25rem; }
        .slide-content ul, .slide-content ol {
            margin-bottom: 1rem;
        }
        .slide-content li {
            margin-bottom: 0.5rem;
        }
        .slide-content blockquote {
            background: #f8f9fa;
            border-left: 4px solid #0d6efd;
            padding: 1rem;
            margin: 1rem 0;
        }
        .slide-content code {
            background: #f8f9fa;
            padding: 0.2rem 0.4rem;
            border-radius: 0.25rem;
            font-size: 0.9em;
        }
        .slide-content pre {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
        }
        
        /* Live Voice Button Styles - HIDDEN UNTIL VERTEX AI INTEGRATION */
        #live-voice-btn {
            display: none !important; /* Hide Live Voice button */
            transition: all 0.3s ease;
        }
        
        #live-voice-btn.btn-danger {
            background-color: #dc3545;
            border-color: #dc3545;
        }
        
        #live-voice-btn.btn-success {
            background-color: #198754;
            border-color: #198754;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(25, 135, 84, 0.7); }
            50% { box-shadow: 0 0 0 10px rgba(25, 135, 84, 0); }
            100% { box-shadow: 0 0 0 0 rgba(25, 135, 84, 0); }
        }
        
        #live-status {
            display: none !important; /* Hide Live Voice status text */
            font-size: 0.75rem;
            min-height: 1rem;
        }
        
        /* Live session chat message styling */
        .message[data-action-type="live-voice"] .message-content {
            position: relative;
        }
        
        .message[data-action-type="live-voice"] .message-content::before {
            content: "ğŸ™ï¸";
            position: absolute;
            left: -20px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.8rem;
        }
        
        .message[data-action-type="live-session"] .message-content {
            border-left: 3px solid #198754;
            padding-left: 8px;
        }
        
        /* PowerPoint-style Layout - Flat design, no shadows */
        .powerpoint-container {
            display: flex;
            height: 100vh;
            width: 100%;
            background: white;
        }
        
        /* Chat Panel - 25% left */
        .chat-panel {
            width: 25%;
            background: #f8f9fa;
            border-right: 1px solid #dee2e6;
            display: flex;
            flex-direction: column;
        }
        
        .chat-header {
            padding: 1rem;
            background: white;
            border-bottom: 1px solid #dee2e6;
            font-weight: 600;
            color: #495057;
        }
        
        /* Chat Messages Area */
        .chat-messages {
            flex: 1;
            padding: 1rem;
            overflow-y: auto;
            background: white;
        }
        
        .message {
            margin-bottom: 1rem;
        }
        
        .message-content {
            padding: 0.75rem 1rem;
            border-radius: 0.375rem;
            max-width: 85%;
            word-wrap: break-word;
        }
        
        /* AI messages - gris clair standard Bootstrap */
        .ai-message .message-content {
            background-color: #f8f9fa;
            color: #495057;
            margin-left: 0;
            border: 1px solid #dee2e6;
        }
        
        /* User messages - fond bleu pÃ¢le comme btn-primary disabled */
        .user-message {
            display: flex;
            justify-content: flex-end;
        }
        
        .user-message .message-content {
            background-color: #b3d7ff;
            color: #004085;
            margin-right: 0;
            border: 1px solid #9fcdff;
        }
        
        /* Chat Actions */
        .chat-actions {
            padding: 0.75rem 1rem;
            background: white;
            border-top: 1px solid #dee2e6;
            border-bottom: 1px solid #dee2e6;
        }
        
        /* Chat Input */
        .chat-input {
            padding: 1rem;
            background: white;
        }
        
        .chat-status {
            font-size: 0.75rem;
            min-height: 1rem;
        }
        
        /* Content Panel - 75% right */
        .content-panel {
            width: 75%;
            background: white;
            display: flex;
            flex-direction: column;
        }
        
        .content-header {
            padding: 1rem;
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
            display: flex;
            justify-content: flex-end;
        }
        
        .learner-info {
            color: #495057;
            font-weight: 500;
        }
        
        /* Progress Bar */
        .progress-bar-container {
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
            padding: 0.75rem 1.5rem;
        }
        
        .progress-breadcrumb {
            font-size: 0.9rem;
            color: #6c757d;
        }
        
        .progress-text {
            font-weight: 500;
        }
        
        .progress-text .current-module {
            color: #0d6efd;
            font-weight: 600;
        }
        
        /* Slide Content Area (scrollable only) */
        .slide-content-area {
            flex: 1;
            padding: 2rem;
            overflow-y: auto;
            background: white;
        }
        
        /* Navigation Bar (fixed at bottom) */
        .navigation-bar {
            background: #f8f9fa;
            border-top: 1px solid #dee2e6;
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .interaction-buttons {
            display: flex;
            align-items: center;
        }
        
        /* Remove Bootstrap shadows for flat design, keep standard rounded corners */
        .btn {
            box-shadow: none !important;
        }
        
        .card {
            box-shadow: none !important;
        }
        
        .form-control {
            box-shadow: none !important;
        }
    </style>
</head>
<body class="bg-white">
    
    <!-- PowerPoint-style Layout: 25% Chat + 75% Content -->
    <div class="powerpoint-container">
        <!-- Left Panel: Chat IA (25%) -->
        <div class="chat-panel">
            <div class="chat-header">
                <i class="bi bi-chat-dots me-2"></i>AI Trainer
            </div>
            
            <!-- Chat Messages Area (scrollable) -->
            <div class="chat-messages" id="chat-messages">
                <!-- Welcome message -->
                <div class="message ai-message">
                    <div class="message-content">
                        Welcome! I'm your AI trainer. I'm here to help you throughout your learning journey. Feel free to ask questions or request exercises and examples.
                    </div>
                </div>
            </div>
            
            <!-- Action Buttons -->
            <div class="chat-actions">
                <div class="btn-group w-100" role="group" aria-label="Chat actions">
                    <button type="button" class="btn btn-outline-primary btn-sm" id="comment-btn">
                        <i class="bi bi-chat-text me-1"></i>Comment
                    </button>
                    <button type="button" class="btn btn-outline-primary btn-sm" id="quiz-btn">
                        <i class="bi bi-question-circle me-1"></i>Quiz
                    </button>
                    <button type="button" class="btn btn-outline-primary btn-sm" id="examples-btn">
                        <i class="bi bi-lightbulb me-1"></i>Examples
                    </button>
                    <button type="button" class="btn btn-outline-primary btn-sm" id="key-points-btn">
                        <i class="bi bi-star me-1"></i>Key Points
                    </button>
                </div>
            </div>
            
            <!-- Chat Input (fixed at bottom) -->
            <div class="chat-input">
                <div class="input-group">
                    <input type="text" class="form-control" id="chat-input" 
                           placeholder="Ask your AI trainer..." maxlength="500">
                    <button class="btn btn-primary" type="button" id="send-message-btn">
                        <i class="bi bi-send"></i>
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Right Panel: Content Area (75%) -->
        <div class="content-panel">
            <!-- Header with learner info -->
            <div class="content-header">
                <div class="learner-info">
                    <i class="bi bi-person-circle me-2"></i>
                    <span id="learner-email">Loading...</span>
                </div>
            </div>
            
            <!-- Progress Bar -->
            <div class="progress-bar-container">
                <div id="progress-breadcrumb" class="progress-breadcrumb">
                    <span class="progress-text">Training Plan</span>
                </div>
            </div>
            
            <!-- Slide Content Area (scrollable) -->
            <div id="main-content" class="slide-content-area">
                <!-- Content will be loaded dynamically -->
            </div>
            
            <!-- Navigation Bar (fixed at bottom) -->
            <div class="navigation-bar">
                <button id="new-previous-btn" class="btn btn-outline-secondary" disabled>
                    <i class="bi bi-chevron-left me-1"></i>Previous
                </button>
                
                <div class="interaction-buttons">
                    <button id="new-simplify-btn" class="btn btn-outline-primary me-2">
                        <i class="bi bi-arrow-down-circle me-1"></i>Simplify
                    </button>
                    <button id="new-more-details-btn" class="btn btn-outline-primary">
                        <i class="bi bi-arrow-up-circle me-1"></i>Deepen
                    </button>
                </div>
                
                <button id="new-next-btn" class="btn btn-outline-primary">
                    Next<i class="bi bi-chevron-right ms-1"></i>
                </button>
            </div>
        </div>
    </div>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Marked.js for markdown parsing (KISS solution) -->
    <script src="https://cdn.jsdelivr.net/npm/marked@9.1.6/marked.min.js"></script>
    
    <script>
        class TrainingApp {
            constructor() {
                this.container = document.getElementById('main-content');
                this.token = this.getTokenFromURL();
                this.sessionData = null;
                this.learnerSession = null;
                this.currentSlide = null; // Track current slide for navigation
                
                if (!this.token) {
                    this.showError('No session token provided');
                    return;
                }
                
                this.init();
            }
            
            getTokenFromURL() {
                const urlParams = new URLSearchParams(window.location.search);
                return urlParams.get('token');
            }
            
            async init() {
                try {
                    console.log('ğŸš€ Initializing TrainingApp with token:', this.token);
                    await this.loadLearnerData();
                    await this.displayTrainingPlan();
                } catch (error) {
                    console.error('Training app initialization error:', error);
                    this.showError(error.message);
                }
            }
            
            async loadLearnerData() {
                try {
                    console.log('ğŸ” Loading learner data for token:', this.token);
                    
                    // Validate session token first
                    const sessionResponse = await fetch(`/api/session/${this.token}`);
                    if (!sessionResponse.ok) {
                        throw new Error('Invalid or expired session token');
                    }
                    
                    const sessionData = await sessionResponse.json();
                    console.log('âœ… Session data loaded:', sessionData);
                    
                    this.sessionData = sessionData;
                    this.learnerSession = sessionData.learner_session;
                    
                    // Update UI with learner info
                    if (this.learnerSession) {
                        document.getElementById('learner-email').textContent = this.learnerSession.email || 'Your Training Session';
                    }
                    
                } catch (error) {
                    console.error('âŒ Error loading learner data:', error);
                    throw new Error(`Failed to load training data: ${error.message}`);
                }
            }
            
            async displayTrainingPlan() {
                // Afficher le loading d'abord
                this.showLoading();
                
                try {
                    console.log('ğŸš€ Starting training plan generation...');
                    
                    // VÃ©rifier qu'on a les donnÃ©es nÃ©cessaires
                    if (!this.learnerSession) {
                        console.log('âš ï¸ No learner session data available, redirecting to profile page...');
                        // Rediriger vers la page de profil si pas de donnÃ©es learner
                        window.location.href = `/frontend/public/session.html?token=${this.token}`;
                        return;
                    }
                    
                    if (!this.sessionData?.training_session?.training_id) {
                        throw new Error('No training ID available');
                    }
                    
                    // PrÃ©parer la requÃªte de gÃ©nÃ©ration de plan
                    const planRequest = {
                        training_id: this.sessionData.training_session.training_id,
                        learner_session_id: this.learnerSession.id,
                        learner_profile: {
                            experience_level: this.learnerSession.experience_level,
                            learning_style: this.learnerSession.learning_style,
                            job_position: this.learnerSession.job_position,
                            activity_sector: this.learnerSession.activity_sector,
                            country: this.learnerSession.country,
                            language: this.learnerSession.language
                        },
                        force_regenerate: false
                    };
                    
                    console.log('ğŸ“ Plan generation request:', planRequest);
                    
                    // Appeler l'API de gÃ©nÃ©ration de plans intÃ©grÃ©e
                    console.log('ğŸ”„ Calling /api/generate-plan-integrated...');
                    const planResponse = await fetch('/api/generate-plan-integrated', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(planRequest)
                    });
                    
                    console.log('ğŸ“Š Plan response status:', planResponse.status);
                    console.log('ğŸ“Š Plan response headers:', [...planResponse.headers.entries()]);
                    
                    if (!planResponse.ok) {
                        const errorText = await planResponse.text();
                        console.error('âŒ Plan generation failed - Raw response:', errorText);
                        
                        let errorData;
                        try {
                            errorData = JSON.parse(errorText);
                        } catch (e) {
                            errorData = { detail: { error_message: errorText } };
                        }
                        
                        console.error('âŒ Plan generation failed:', errorData);
                        throw new Error(`Plan generation failed: ${errorData.detail?.error_message || planResponse.statusText}`);
                    }
                    
                    const planData = await planResponse.json();
                    console.log('âœ… Plan generated successfully:', planData);
                    
                    // Afficher le plan gÃ©nÃ©rÃ©
                    this.renderGeneratedPlan(planData);
                    
                } catch (error) {
                    console.error('âŒ Error generating training plan:', error);
                    this.showError(`Failed to generate training plan: ${error.message}`);
                }
            }
            
            showLoading() {
                this.container.innerHTML = `
                    <div class="row">
                        <div class="col-12">
                            <div class="card shadow-sm">
                                <div class="card-body text-center py-5">
                                    <div class="spinner-border text-primary mb-3" role="status" style="width: 3rem; height: 3rem;">
                                        <span class="visually-hidden">Loading...</span>
                                    </div>
                                    <h5 class="card-title">Generating Your Personalized Training Plan</h5>
                                    <p class="card-text text-muted">
                                        Our AI is analyzing your profile and creating a customized learning experience...
                                        <br>This may take a few moments.
                                    </p>
                                    <div class="progress mt-3" style="height: 6px;">
                                        <div class="progress-bar progress-bar-striped progress-bar-animated" 
                                             role="progressbar" style="width: 100%"></div>
                                    </div>
                                    
                                    <div class="mt-4">
                                        <small class="text-muted">
                                            <strong>Debug Info:</strong><br>
                                            Session Token: ${this.token}<br>
                                            Training ID: ${this.sessionData?.training_session?.training_id || 'Loading...'}<br>
                                            Learner Email: ${this.learnerSession?.email || 'Loading...'}
                                        </small>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            renderGeneratedPlan(planData) {
                console.log('ğŸ¨ Rendering generated plan:', planData);
                
                const trainingPlan = planData.training_plan;
                const metadata = planData.generation_metadata;
                
                let accordionHTML = '';
                trainingPlan.stages.forEach((stage, stageIndex) => {
                    let modulesHTML = '';
                    stage.modules.forEach((module, moduleIndex) => {
                        let submodulesHTML = '';
                        module.submodules.forEach((submodule, submoduleIndex) => {
                            submodulesHTML += `
                                <div class="col-md-6 mb-2">
                                    <div class="card border-light bg-light">
                                        <div class="card-body p-3">
                                            <h6 class="card-title text-primary">${submodule.submodule_name}</h6>
                                            <span class="badge bg-secondary">${submodule.slide_count} slides</span>
                                        </div>
                                    </div>
                                </div>
                            `;
                        });
                        
                        modulesHTML += `
                            <div class="mb-3">
                                <h6 class="text-dark">${module.module_name}</h6>
                                <div class="row">${submodulesHTML}</div>
                            </div>
                        `;
                    });
                    
                    const isFirstStage = stageIndex === 0;
                    accordionHTML += `
                        <div class="accordion-item">
                            <h2 class="accordion-header">
                                <button class="accordion-button ${isFirstStage ? '' : 'collapsed'}" type="button" 
                                        data-bs-toggle="collapse" data-bs-target="#stage${stage.stage_number}">
                                    <i class="bi bi-mortarboard me-2 text-primary"></i>
                                    Ã‰tape ${stage.stage_number}: ${stage.stage_name}
                                </button>
                            </h2>
                            <div id="stage${stage.stage_number}" class="accordion-collapse collapse ${isFirstStage ? 'show' : ''}">
                                <div class="accordion-body">
                                    ${modulesHTML}
                                </div>
                            </div>
                        </div>
                    `;
                });
                
                this.container.innerHTML = `
                    <div class="row">
                        <div class="col-md-12">
                            <div class="card shadow-sm">
                                <div class="card-header bg-primary text-white">
                                    <h5 class="mb-0">
                                        <i class="bi bi-book me-2"></i>Your Personalized Training Plan
                                    </h5>
                                </div>
                                <div class="card-body">
                                    
                                    <div class="row mb-3">
                                        <div class="col-md-3">
                                            <div class="text-center">
                                                <div class="h4 text-primary">${metadata.total_stages}</div>
                                                <small class="text-muted">Stages</small>
                                            </div>
                                        </div>
                                        <div class="col-md-3">
                                            <div class="text-center">
                                                <div class="h4 text-info">${metadata.total_modules}</div>
                                                <small class="text-muted">Modules</small>
                                            </div>
                                        </div>
                                        <div class="col-md-3">
                                            <div class="text-center">
                                                <div class="h4 text-success">${metadata.total_slides}</div>
                                                <small class="text-muted">Slides</small>
                                            </div>
                                        </div>
                                        <div class="col-md-3">
                                            <div class="text-center">
                                                <div class="h4 text-warning">${metadata.database_integration?.generation_time_seconds || 0}s</div>
                                                <small class="text-muted">Generation Time</small>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <h6 class="text-muted mb-3">Training Structure:</h6>
                                    <div class="accordion" id="trainingAccordion">
                                        ${accordionHTML}
                                    </div>
                                    
                                    <div class="mt-4">
                                        <button class="btn btn-primary me-2" id="start-training-btn">
                                            <i class="bi bi-play-circle me-1"></i>Start Training
                                        </button>
                                        <button class="btn btn-outline-secondary me-2">
                                            <i class="bi bi-download me-1"></i>Download Plan
                                        </button>
                                        <button class="btn btn-outline-info" onclick="location.reload()">
                                            <i class="bi bi-arrow-clockwise me-1"></i>Regenerate
                                        </button>
                                    </div>
                                    
                                    <!-- Debug Information -->
                                    <div class="mt-4">
                                        <details>
                                            <summary class="text-muted">Debug Information</summary>
                                            <pre class="bg-light p-3 mt-2 small">${JSON.stringify(metadata, null, 2)}</pre>
                                        </details>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                
                // Ajouter l'event listener pour le bouton Start Training
                const startButton = document.getElementById('start-training-btn');
                if (startButton) {
                    startButton.addEventListener('click', () => this.startTraining());
                }
            }
            
            async startTraining() {
                try {
                    console.log('ğŸš€ Starting training for session:', this.learnerSession.id);
                    
                    // GÃ©nÃ©rer et afficher la premiÃ¨re slide
                    await this.generateAndDisplayFirstSlide();
                    
                } catch (error) {
                    console.error('âŒ Error starting training:', error);
                    this.showError(`Failed to start training: ${error.message}`);
                }
            }
            
            async generateAndDisplayFirstSlide() {
                try {
                    console.log('ğŸ¯ [API] === DÃ‰BUT GÃ‰NÃ‰RATION PREMIÃˆRE SLIDE ===');
                    console.log('ğŸ¯ [API] Session ID:', this.learnerSession.id);
                    
                    // Afficher loading pendant gÃ©nÃ©ration
                    this.showSlideLoading();
                    
                    // Appeler l'API pour gÃ©nÃ©rer la premiÃ¨re slide
                    console.log('ğŸ”„ [API] Appel API /api/slides/generate-first/${this.learnerSession.id}');
                    const response = await fetch(`/api/slides/generate-first/${this.learnerSession.id}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    console.log('ğŸ“¡ [API] RESPONSE STATUS:', response.status);
                    console.log('ğŸ“¡ [API] RESPONSE OK:', response.ok);
                    console.log('ğŸ“¡ [API] RESPONSE HEADERS:', [...response.headers.entries()]);
                    
                    if (!response.ok) {
                        console.log('âŒ [API] RESPONSE NOT OK - RÃ©cupÃ©ration erreur...');
                        const errorData = await response.json();
                        console.log('âŒ [API] ERROR DATA:', errorData);
                        throw new Error(errorData.detail || 'Failed to generate first slide');
                    }
                    
                    console.log('ğŸ”„ [API] Parsing JSON response...');
                    const slideData = await response.json();
                    console.log('âœ… [API] SLIDE DATA REÃ‡UE (COMPLET):', slideData);
                    console.log('âœ… [API] SLIDE DATA TYPE:', typeof slideData);
                    console.log('âœ… [API] SLIDE DATA KEYS:', Object.keys(slideData));
                    
                    if (slideData.data) {
                        console.log('ğŸ” [API] slideData.data TYPE:', typeof slideData.data);
                        console.log('ğŸ” [API] slideData.data KEYS:', Object.keys(slideData.data));
                        console.log('ğŸ” [API] slideData.data COMPLET:', slideData.data);
                        
                        if (slideData.data.title) {
                            console.log('ğŸ“‹ [API] TITRE DÃ‰TECTÃ‰:', slideData.data.title);
                        }
                        if (slideData.data.slide_content) {
                            console.log('ğŸ“‹ [API] SLIDE_CONTENT DÃ‰TECTÃ‰ (longueur):', slideData.data.slide_content.length);
                            console.log('ğŸ“‹ [API] SLIDE_CONTENT PREVIEW:', slideData.data.slide_content.substring(0, 150) + '...');
                        }
                        if (slideData.data.content) {
                            console.log('ğŸ“‹ [API] CONTENT DÃ‰TECTÃ‰ (longueur):', slideData.data.content.length);
                            console.log('ğŸ“‹ [API] CONTENT PREVIEW:', slideData.data.content.substring(0, 150) + '...');
                        }
                    } else {
                        console.log('âš ï¸ [API] PAS DE slideData.data - Structure diffÃ©rente?');
                        console.log('ğŸ” [API] Analyse structure alternative...');
                        if (slideData.title) {
                            console.log('ğŸ“‹ [API] TITRE DIRECT:', slideData.title);
                        }
                        if (slideData.slide_content) {
                            console.log('ğŸ“‹ [API] SLIDE_CONTENT DIRECT:', slideData.slide_content.substring(0, 150) + '...');
                        }
                    }
                    
                    console.log('ğŸ¨ [API] === PASSAGE Ã€ DISPLAYSLIDE ===');
                    // Afficher la slide - passer les bonnes donnÃ©es
                    this.displaySlideContent(slideData.data || slideData);
                    
                } catch (error) {
                    console.error('âŒ [API] ERROR generateAndDisplayFirstSlide:', error);
                    console.error('âŒ [API] ERROR STACK:', error.stack);
                    throw error;
                }
            }
            
            showSlideLoading() {
                this.container.innerHTML = `
                    <div class="row">
                        <div class="col-lg-12">
                            <div class="card shadow-sm">
                                <div class="card-body text-center py-5">
                                    <div class="spinner-border text-primary mb-3" role="status" style="width: 3rem; height: 3rem;">
                                        <span class="visually-hidden">Loading...</span>
                                    </div>
                                    <h5 class="card-title">Generating Your First Slide</h5>
                                    <p class="card-text text-muted">
                                        Our AI is creating personalized content based on your profile...
                                    </p>
                                    <div class="progress mt-3" style="height: 6px;">
                                        <div class="progress-bar progress-bar-striped progress-bar-animated" 
                                             role="progressbar" style="width: 100%"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            displaySlideContent(slideData) {
                // Store current slide data for navigation
                this.currentSlide = slideData;
                console.log('ğŸ¨ [DISPLAY] === DÃ‰BUT ANALYSE DES DONNÃ‰ES ===');
                console.log('ğŸ¨ [DISPLAY] slideData TYPE:', typeof slideData);
                console.log('ğŸ¨ [DISPLAY] slideData COMPLET:', slideData);
                console.log('ğŸ¨ [DISPLAY] slideData.title:', slideData.title);
                console.log('ğŸ¨ [DISPLAY] slideData.slide_content:', slideData.slide_content);
                console.log('ğŸ¨ [DISPLAY] slideData.content:', slideData.content);
                console.log('ğŸ¨ [DISPLAY] slideData.slide:', slideData.slide);
                
                // KISS: Extract content directly from the data structure
                // slideData peut contenir slide_content (format JSON), content, ou slide.content
                let title, content;
                
                if (slideData.title && slideData.slide_content) {
                    // Structure avec slide_content (format JSON de l'API)
                    console.log('ğŸ¯ [DISPLAY] BRANCHE 1: title + slide_content dÃ©tectÃ©s');
                    title = slideData.title;
                    content = slideData.slide_content;
                    console.log('ğŸ¯ [DISPLAY] BRANCHE 1: title =', title);
                    console.log('ğŸ¯ [DISPLAY] BRANCHE 1: content =', content);
                } else if (slideData.title && slideData.content) {
                    // Structure directe
                    console.log('ğŸ¯ [DISPLAY] BRANCHE 2: title + content dÃ©tectÃ©s');
                    title = slideData.title;
                    content = slideData.content;
                    console.log('ğŸ¯ [DISPLAY] BRANCHE 2: title =', title);
                    console.log('ğŸ¯ [DISPLAY] BRANCHE 2: content =', content);
                } else if (slideData.slide) {
                    // Structure avec "slide" wrapper
                    console.log('ğŸ¯ [DISPLAY] BRANCHE 3: slide wrapper dÃ©tectÃ©');
                    title = slideData.slide.title;
                    content = slideData.slide.content || slideData.slide.slide_content;
                    console.log('ğŸ¯ [DISPLAY] BRANCHE 3: title =', title);
                    console.log('ğŸ¯ [DISPLAY] BRANCHE 3: content =', content);
                } else {
                    // Fallback
                    console.log('ğŸ¯ [DISPLAY] BRANCHE 4: FALLBACK utilisÃ©');
                    title = 'Formation Content';
                    content = slideData.slide_content || slideData.content || JSON.stringify(slideData);
                    console.log('ğŸ¯ [DISPLAY] BRANCHE 4: title =', title);
                    console.log('ğŸ¯ [DISPLAY] BRANCHE 4: content =', content);
                }
                
                console.log('ğŸ“ [DISPLAY] EXTRACTION FINALE:');
                console.log('ğŸ“ [DISPLAY] title FINAL =', title);
                console.log('ğŸ“ [DISPLAY] content FINAL (type):', typeof content);
                console.log('ğŸ“ [DISPLAY] content FINAL (longueur):', content ? content.length : 'NULL');
                console.log('ğŸ“ [DISPLAY] content FINAL (preview):', content ? content.substring(0, 100) + '...' : 'NULL');
                console.log('ğŸ¨ [DISPLAY] === AVANT PASSAGE Ã€ MARKDOWN ===');
                
                // Stocker le contenu markdown original pour les fonctionnalitÃ©s d'interaction
                this.currentSlideContent = content;
                console.log('ğŸ’¾ [DISPLAY] Current slide content stored for interactions');
                
                this.container.innerHTML = `
                    <div class="row">
                        <!-- Main slide content (full width) -->
                        <div class="col-lg-12">
                            <div class="card shadow-sm">
                                <div class="card-header bg-primary text-white d-flex justify-content-between align-items-center">
                                    <h5 class="mb-0">
                                        <i class="bi bi-file-slides me-2"></i>${title}
                                    </h5>
                                    <div>
                                        <span class="badge bg-light text-dark">Slide ${slideData.order_in_submodule || 1}</span>
                                    </div>
                                </div>
                                <div class="card-body">
                                    <!-- Slide content in markdown format -->
                                    <div id="slide-content" class="slide-content">
                                        ${this.markdownToHtml(content)}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                
                // Ajouter event listeners pour le chat
                this.setupChatFunctionality();
                this.setupContextualChatButtons();
                this.setupSlideInteractionButtons();
                this.setupNewNavigationButtons(); // Connect new navigation buttons
                this.setupLiveVoiceFunctionality();
                
                // Update navigation button states
                this.updateNavigationButtonStates();
            }
            
            markdownToHtml(markdown) {
                console.log('ğŸ“–ğŸ“–ğŸ“– [MARKDOWN] ============== DÃ‰BUT TRAITEMENT MARKDOWN ==============');
                console.log('ğŸ“–ğŸ“–ğŸ“– [MARKDOWN] markdown TYPE:', typeof markdown);
                console.log('ğŸ“–ğŸ“–ğŸ“– [MARKDOWN] markdown NULL/UNDEFINED?', markdown == null);
                console.log('ğŸ“–ğŸ“–ğŸ“– [MARKDOWN] markdown LONGUEUR:', markdown ? markdown.length : 'N/A');
                console.log('ğŸ“–ğŸ“–ğŸ“– [MARKDOWN] markdown IS STRING?:', typeof markdown === 'string');
                console.log('ğŸ“–ğŸ“–ğŸ“– [MARKDOWN] markdown PREVIEW (300 chars):');
                console.log('ğŸ“–ğŸ“–ğŸ“– [MARKDOWN] ---START PREVIEW---');
                console.log(markdown ? markdown.substring(0, 300) : 'NULL');
                console.log('ğŸ“–ğŸ“–ğŸ“– [MARKDOWN] ---END PREVIEW---');
                console.log('ğŸ“–ğŸ“–ğŸ“– [MARKDOWN] marked DISPONIBLE?:', typeof marked !== 'undefined');
                console.log('ğŸ“–ğŸ“–ğŸ“– [MARKDOWN] marked.parse DISPONIBLE?:', typeof marked?.parse === 'function');
                
                // Analyse dÃ©taillÃ©e du contenu
                if (markdown) {
                    console.log('ğŸ”ğŸ”ğŸ” [MARKDOWN] ANALYSE DÃ‰TAILLÃ‰E DU CONTENU:');
                    console.log('ğŸ”ğŸ”ğŸ” [MARKDOWN] Contient des # (titres)?', markdown.includes('#'));
                    console.log('ğŸ”ğŸ”ğŸ” [MARKDOWN] Contient des * (listes)?', markdown.includes('*'));
                    console.log('ğŸ”ğŸ”ğŸ” [MARKDOWN] Contient des | (tableaux)?', markdown.includes('|'));
                    console.log('ğŸ”ğŸ”ğŸ” [MARKDOWN] Contient des \\n (sauts de ligne)?', markdown.includes('\n'));
                    console.log('ğŸ”ğŸ”ğŸ” [MARKDOWN] Nombre de sauts de ligne:', (markdown.match(/\n/g) || []).length);
                    
                    // Afficher les premiÃ¨res et derniÃ¨res lignes
                    const lines = markdown.split('\n');
                    console.log('ğŸ”ğŸ”ğŸ” [MARKDOWN] Nombre total de lignes:', lines.length);
                    console.log('ğŸ”ğŸ”ğŸ” [MARKDOWN] PremiÃ¨res 5 lignes:');
                    lines.slice(0, 5).forEach((line, index) => {
                        console.log(`ğŸ”ğŸ”ğŸ” [MARKDOWN] Ligne ${index + 1}: "${line}"`);
                    });
                    
                    if (lines.length > 10) {
                        console.log('ğŸ”ğŸ”ğŸ” [MARKDOWN] ... (lignes intermÃ©diaires cachÃ©es) ...');
                        console.log('ğŸ”ğŸ”ğŸ” [MARKDOWN] DerniÃ¨res 3 lignes:');
                        lines.slice(-3).forEach((line, index) => {
                            console.log(`ğŸ”ğŸ”ğŸ” [MARKDOWN] Ligne ${lines.length - 3 + index + 1}: "${line}"`);
                        });
                    }
                }
                
                if (!markdown) {
                    console.log('âš ï¸âš ï¸âš ï¸ [MARKDOWN] CONTENU VIDE - Retour message par dÃ©faut');
                    const defaultHtml = '<p>Content is being generated...</p>';
                    console.log('ğŸ”„ğŸ”„ğŸ”„ [MARKDOWN] DEFAULT HTML:', defaultHtml);
                    return defaultHtml;
                }
                
                try {
                    console.log('ğŸ”„ğŸ”„ğŸ”„ [MARKDOWN] DÃ‰BUT PARSING avec marked.parse...');
                    console.log('ğŸ”„ğŸ”„ğŸ”„ [MARKDOWN] Input exact pour marked.parse:');
                    console.log('ğŸ”„ğŸ”„ğŸ”„ [MARKDOWN] ---START INPUT---');
                    console.log(markdown.substring(0, 500));
                    console.log('ğŸ”„ğŸ”„ğŸ”„ [MARKDOWN] ---END INPUT---');
                    
                    // KISS: Use marked.js for proper markdown parsing
                    const htmlResult = marked.parse(markdown);
                    
                    console.log('âœ…âœ…âœ… [MARKDOWN] PARSING RÃ‰USSI!');
                    console.log('ğŸ“ğŸ“ğŸ“ [MARKDOWN] HTML RÃ‰SULTAT TYPE:', typeof htmlResult);
                    console.log('ğŸ“ğŸ“ğŸ“ [MARKDOWN] HTML RÃ‰SULTAT LONGUEUR:', htmlResult ? htmlResult.length : 'N/A');
                    console.log('ğŸ“ğŸ“ğŸ“ [MARKDOWN] HTML RÃ‰SULTAT IS STRING?:', typeof htmlResult === 'string');
                    console.log('ğŸ“ğŸ“ğŸ“ [MARKDOWN] HTML RÃ‰SULTAT PREVIEW (400 chars):');
                    console.log('ğŸ“ğŸ“ğŸ“ [MARKDOWN] ---START HTML RESULT---');
                    console.log(htmlResult ? htmlResult.substring(0, 400) + '...' : 'NULL');
                    console.log('ğŸ“ğŸ“ğŸ“ [MARKDOWN] ---END HTML RESULT---');
                    
                    // Analyser le HTML gÃ©nÃ©rÃ©
                    if (htmlResult) {
                        console.log('ğŸ”ğŸ”ğŸ” [MARKDOWN] ANALYSE HTML GÃ‰NÃ‰RÃ‰:');
                        console.log('ğŸ”ğŸ”ğŸ” [MARKDOWN] Contient <h1>?', htmlResult.includes('<h1>'));
                        console.log('ğŸ”ğŸ”ğŸ” [MARKDOWN] Contient <h2>?', htmlResult.includes('<h2>'));
                        console.log('ğŸ”ğŸ”ğŸ” [MARKDOWN] Contient <ul>?', htmlResult.includes('<ul>'));
                        console.log('ğŸ”ğŸ”ğŸ” [MARKDOWN] Contient <table>?', htmlResult.includes('<table>'));
                        console.log('ğŸ”ğŸ”ğŸ” [MARKDOWN] Contient <p>?', htmlResult.includes('<p>'));
                        
                        // Compter les balises
                        const h1Count = (htmlResult.match(/<h1>/g) || []).length;
                        const h2Count = (htmlResult.match(/<h2>/g) || []).length;
                        const tableCount = (htmlResult.match(/<table>/g) || []).length;
                        const pCount = (htmlResult.match(/<p>/g) || []).length;
                        
                        console.log('ğŸ”ğŸ”ğŸ” [MARKDOWN] Nombre de <h1>:', h1Count);
                        console.log('ğŸ”ğŸ”ğŸ” [MARKDOWN] Nombre de <h2>:', h2Count);
                        console.log('ğŸ”ğŸ”ğŸ” [MARKDOWN] Nombre de <table>:', tableCount);
                        console.log('ğŸ”ğŸ”ğŸ” [MARKDOWN] Nombre de <p>:', pCount);
                    }
                    
                    console.log('ğŸ“–ğŸ“–ğŸ“– [MARKDOWN] ============== FIN TRAITEMENT MARKDOWN SUCCÃˆS ==============');
                    return htmlResult;
                    
                } catch (error) {
                    console.error('âŒâŒâŒ [MARKDOWN] ERREUR PARSING:', error);
                    console.error('âŒâŒâŒ [MARKDOWN] ERROR MESSAGE:', error.message);
                    console.error('âŒâŒâŒ [MARKDOWN] ERROR STACK:', error.stack);
                    console.log('ğŸ”„ğŸ”„ğŸ”„ [MARKDOWN] FALLBACK: Conversion simple \\n -> <br>');
                    
                    // Fallback to plain text with line breaks
                    const fallbackResult = markdown.replace(/\n/g, '<br>');
                    console.log('ğŸ“ğŸ“ğŸ“ [MARKDOWN] FALLBACK RÃ‰SULTAT LONGUEUR:', fallbackResult.length);
                    console.log('ğŸ“ğŸ“ğŸ“ [MARKDOWN] FALLBACK RÃ‰SULTAT PREVIEW (300 chars):', fallbackResult.substring(0, 300) + '...');
                    console.log('ğŸ“–ğŸ“–ğŸ“– [MARKDOWN] ============== FIN TRAITEMENT MARKDOWN FALLBACK ==============');
                    return fallbackResult;
                }
            }
            
            setupChatFunctionality() {
                const chatInput = document.getElementById('chat-input');
                const sendButton = document.getElementById('send-message-btn');
                const chatMessages = document.getElementById('chat-messages');
                
                if (chatInput && sendButton && chatMessages) {
                    const sendMessage = async () => {
                        const message = chatInput.value.trim();
                        if (!message) return;
                        
                        console.log('ğŸ’¬ [CHAT] Sending message:', message);
                        
                        // DÃ©sactiver l'input et le bouton pendant l'envoi
                        chatInput.disabled = true;
                        sendButton.disabled = true;
                        sendButton.innerHTML = '<i class="bi bi-hourglass-split"></i>';
                        
                        // Ajouter le message de l'utilisateur au chat
                        this.addChatMessage('user', message);
                        chatInput.value = '';
                        
                        try {
                            // PrÃ©parer la requÃªte chat
                            const chatRequest = {
                                message: message,
                                context: {
                                    training_id: this.sessionData.training_session.training_id,
                                    learner_session_id: this.learnerSession.id,
                                    current_slide_id: null, // TODO: Add current slide ID when available
                                    training_content: "Current slide content", // TODO: Get actual current slide content
                                    learner_profile: {
                                        experience_level: this.learnerSession.experience_level,
                                        learning_style: this.learnerSession.learning_style,
                                        job_position: this.learnerSession.job_position,
                                        activity_sector: this.learnerSession.activity_sector,
                                        country: this.learnerSession.country,
                                        language: this.learnerSession.language
                                    },
                                    conversation_history: this.getChatHistory()
                                },
                                conversation_type: "general"
                            };
                            
                            console.log('ğŸ“¤ [CHAT] Request payload:', chatRequest);
                            
                            // Appeler l'API chat
                            const response = await fetch('/api/chat', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify(chatRequest)
                            });
                            
                            console.log('ğŸ“¥ [CHAT] Response status:', response.status);
                            console.log('ğŸ“¥ [CHAT] Response headers:', [...response.headers.entries()]);
                            
                            if (!response.ok) {
                                const errorData = await response.json();
                                console.error('âŒ [CHAT] Error response:', errorData);
                                throw new Error(errorData.detail || 'Chat service temporarily unavailable');
                            }
                            
                            const chatResponse = await response.json();
                            console.log('âœ… [CHAT] Success response:', chatResponse);
                            
                            // Ajouter la rÃ©ponse de l'IA au chat
                            this.addChatMessage('assistant', chatResponse.response, {
                                confidence: chatResponse.confidence_score,
                                suggested_actions: chatResponse.suggested_actions,
                                related_concepts: chatResponse.related_concepts
                            });
                            
                        } catch (error) {
                            console.error('âŒ [CHAT] Error:', error);
                            this.addChatMessage('assistant', 
                                `I'm sorry, I encountered an error. Please try again. (${error.message})`,
                                { error: true }
                            );
                        } finally {
                            // RÃ©activer l'input et le bouton
                            chatInput.disabled = false;
                            sendButton.disabled = false;
                            sendButton.innerHTML = '<i class="bi bi-send"></i>';
                            chatInput.focus();
                        }
                    };
                    
                    sendButton.addEventListener('click', sendMessage);
                    chatInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter' && !e.shiftKey) {
                            e.preventDefault();
                            sendMessage();
                        }
                    });
                }
            }
            
            addChatMessage(role, content, metadata = {}) {
                const chatMessages = document.getElementById('chat-messages');
                
                const isUser = role === 'user';
                const messageClass = isUser ? 'justify-content-end' : '';
                const bubbleClass = isUser ? 'bg-primary text-white' : 'bg-light';
                
                // Add action type badge for contextual actions
                let actionTypeBadge = '';
                if (metadata.action_type) {
                    const badgeConfig = {
                        'comment': { class: 'bg-primary', icon: 'bi-chat-text', text: 'Comment' },
                        'quiz': { class: 'bg-secondary', icon: 'bi-question-circle', text: 'Quiz' },
                        'examples': { class: 'bg-info', icon: 'bi-lightbulb', text: 'Examples' },
                        'key-points': { class: 'bg-warning text-dark', icon: 'bi-star', text: 'Key Points' }
                    };
                    
                    const config = badgeConfig[metadata.action_type];
                    if (config) {
                        actionTypeBadge = `<div class="mt-1 mb-2"><span class="badge ${config.class}"><i class="${config.icon} me-1"></i>${config.text}</span></div>`;
                    }
                }

                const messageHtml = `
                    <div class="p-3">
                        <div class="message ${role} mb-3" ${metadata.action_type ? `data-action-type="${metadata.action_type}"` : ''}>
                            <div class="d-flex align-items-start ${messageClass}">
                                <div class="message-content">
                                    <div class="${bubbleClass} p-2 rounded">
                                        ${actionTypeBadge}
                                        <p class="mb-0 small">${content}</p>
                                        ${metadata.confidence ? `<div class="mt-1"><span class="badge bg-secondary">Confidence: ${Math.round(metadata.confidence * 100)}%</span></div>` : ''}
                                        ${metadata.suggested_actions && metadata.suggested_actions.length > 0 ? 
                                            `<div class="mt-2">
                                                <small class="text-muted">Suggestions:</small><br>
                                                ${metadata.suggested_actions.map(action => `<span class="badge bg-info me-1">${action}</span>`).join('')}
                                            </div>` : ''}
                                        ${metadata.related_concepts && metadata.related_concepts.length > 0 ? 
                                            `<div class="mt-2">
                                                <small class="text-muted">Related:</small><br>
                                                ${metadata.related_concepts.map(concept => `<span class="badge bg-success me-1">${concept}</span>`).join('')}
                                            </div>` : ''}
                                        ${metadata.error ? `<div class="mt-1"><span class="badge bg-danger">Error</span></div>` : ''}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                
                chatMessages.insertAdjacentHTML('beforeend', messageHtml);
                chatMessages.scrollTop = chatMessages.scrollHeight;
                
                console.log('ğŸ’¬ [CHAT] Message added:', { role, content: content.substring(0, 50) + '...', metadata });
            }
            
            getChatHistory() {
                // RÃ©cupÃ©rer l'historique des messages du DOM
                const messages = [];
                const messageElements = document.querySelectorAll('#chat-messages .message');
                
                messageElements.forEach(element => {
                    const role = element.classList.contains('assistant') ? 'assistant' : 'user';
                    const content = element.querySelector('.message-content p')?.textContent || '';
                    const timestamp = element.querySelector('small')?.textContent || new Date().toISOString();
                    
                    if (content.trim()) {
                        messages.push({
                            role: role,
                            content: content,
                            timestamp: timestamp,
                            metadata: {}
                        });
                    }
                });
                
                console.log('ğŸ“ [CHAT] Chat history retrieved:', messages.length, 'messages');
                return messages.slice(-10); // Garder seulement les 10 derniers messages pour le contexte
            }
            
            setupContextualChatButtons() {
                const commentBtn = document.getElementById('comment-btn');
                const quizBtn = document.getElementById('quiz-btn');
                const examplesBtn = document.getElementById('examples-btn');
                const keyPointsBtn = document.getElementById('key-points-btn');
                
                if (commentBtn) {
                    commentBtn.addEventListener('click', () => this.handleContextualAction('comment'));
                    console.log('âœ… [CONTEXTUAL_CHAT] Comment button event listener added');
                }
                
                if (quizBtn) {
                    quizBtn.addEventListener('click', () => this.handleContextualAction('quiz'));
                    console.log('âœ… [CONTEXTUAL_CHAT] Quiz button event listener added');
                }
                
                if (examplesBtn) {
                    examplesBtn.addEventListener('click', () => this.handleContextualAction('examples'));
                    console.log('âœ… [CONTEXTUAL_CHAT] Examples button event listener added');
                }
                
                if (keyPointsBtn) {
                    keyPointsBtn.addEventListener('click', () => this.handleContextualAction('key-points'));
                    console.log('âœ… [CONTEXTUAL_CHAT] Key Points button event listener added');
                }
            }
            
            async handleContextualAction(actionType) {
                console.log(`ğŸ’¬ [CONTEXTUAL_CHAT] Handling ${actionType} action`);
                
                if (!this.currentSlideContent || !this.currentSlide) {
                    console.error('âŒ [CONTEXTUAL_CHAT] No current slide content available');
                    this.addChatMessage('assistant', 
                        'I need slide content to provide this information. Please wait for the slide to load.',
                        { error: true }
                    );
                    return;
                }
                
                // Disable all contextual buttons during processing
                this.setContextualButtonsEnabled(false, actionType);
                
                try {
                    // Prepare request payload
                    const requestPayload = {
                        learner_session_id: this.learnerSession.id,
                        slide_content: this.currentSlideContent,
                        slide_title: this.currentSlide.title || 'Current Slide'
                    };
                    
                    console.log(`ğŸ“¤ [CONTEXTUAL_CHAT] ${actionType} request payload:`, requestPayload);
                    
                    // Call the appropriate API endpoint
                    const apiEndpoint = `/api/chat/${actionType}`;
                    const response = await fetch(apiEndpoint, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(requestPayload)
                    });
                    
                    console.log(`ğŸ“¥ [CONTEXTUAL_CHAT] ${actionType} response status:`, response.status);
                    
                    if (!response.ok) {
                        const errorData = await response.json();
                        console.error(`âŒ [CONTEXTUAL_CHAT] ${actionType} error response:`, errorData);
                        throw new Error(errorData.detail || `${actionType} service temporarily unavailable`);
                    }
                    
                    const chatResponse = await response.json();
                    console.log(`âœ… [CONTEXTUAL_CHAT] ${actionType} success response:`, chatResponse);
                    
                    // Add AI response to chat with appropriate metadata
                    this.addChatMessage('assistant', chatResponse.response, {
                        confidence: chatResponse.confidence_score,
                        suggested_actions: chatResponse.suggested_actions,
                        related_concepts: chatResponse.related_concepts,
                        action_type: actionType
                    });
                    
                } catch (error) {
                    console.error(`âŒ [CONTEXTUAL_CHAT] ${actionType} error:`, error);
                    
                    // Add error message to chat
                    let errorMessage = `I'm sorry, I encountered an error while processing your ${actionType} request. Please try again.`;
                    if (actionType === 'comment') errorMessage = 'I cannot comment on this slide right now. Please try again later.';
                    else if (actionType === 'quiz') errorMessage = 'I cannot generate a quiz right now. Please try again later.';
                    else if (actionType === 'examples') errorMessage = 'I cannot provide examples right now. Please try again later.';
                    else if (actionType === 'key-points') errorMessage = 'I cannot extract key points right now. Please try again later.';
                    
                    this.addChatMessage('assistant', `${errorMessage} (${error.message})`, { error: true });
                    
                } finally {
                    // Re-enable contextual buttons
                    this.setContextualButtonsEnabled(true);
                }
            }
            
            setContextualButtonsEnabled(enabled, activeActionType = null) {
                const buttons = {
                    'comment': document.getElementById('comment-btn'),
                    'quiz': document.getElementById('quiz-btn'),
                    'examples': document.getElementById('examples-btn'),
                    'key-points': document.getElementById('key-points-btn')
                };
                
                Object.entries(buttons).forEach(([actionType, button]) => {
                    if (button) {
                        if (enabled) {
                            button.disabled = false;
                            // Restore original content
                            if (actionType === 'comment') button.innerHTML = '<i class="bi bi-chat-text me-1"></i>Comment';
                            else if (actionType === 'quiz') button.innerHTML = '<i class="bi bi-question-circle me-1"></i>Quiz';
                            else if (actionType === 'examples') button.innerHTML = '<i class="bi bi-lightbulb me-1"></i>Examples';
                            else if (actionType === 'key-points') button.innerHTML = '<i class="bi bi-star me-1"></i>Key Points';
                        } else {
                            if (actionType === activeActionType) {
                                button.disabled = true;
                                button.innerHTML = '<i class="bi bi-hourglass-split me-1"></i>Loading...';
                            } else {
                                button.disabled = true;
                            }
                        }
                    }
                });
            }
            
            updateNavigationButtonStates() {
                const newPreviousBtn = document.getElementById('new-previous-btn');
                const newNextBtn = document.getElementById('new-next-btn');
                
                if (!this.currentSlide || !this.currentSlide.position) {
                    console.log('ğŸ”„ [NAVIGATION] No position data available, keeping buttons enabled');
                    return;
                }
                
                const position = this.currentSlide.position;
                console.log('ğŸ”„ [NAVIGATION] Updating button states:', position);
                
                // Update Previous button
                if (newPreviousBtn) {
                    if (position.has_previous === false) {
                        newPreviousBtn.disabled = true;
                        newPreviousBtn.classList.add('opacity-50');
                        console.log('ğŸ”„ [NAVIGATION] Previous button disabled - at beginning');
                    } else {
                        newPreviousBtn.disabled = false;
                        newPreviousBtn.classList.remove('opacity-50');
                        console.log('ğŸ”„ [NAVIGATION] Previous button enabled');
                    }
                }
                
                // Update Next button
                if (newNextBtn) {
                    if (position.has_next === false) {
                        newNextBtn.disabled = true;
                        newNextBtn.classList.add('opacity-50');
                        newNextBtn.innerHTML = '<i class="bi bi-check-circle me-1"></i>Complete';
                    } else {
                        newNextBtn.disabled = false;
                        newNextBtn.classList.remove('opacity-50');
                        newNextBtn.innerHTML = 'Next<i class="bi bi-chevron-right ms-1"></i>';
                        console.log('ğŸ”„ [NAVIGATION] Next button enabled');
                    }
                }
                
                // Show progress info
                if (position.current_position && position.total_slides) {
                    console.log(`ğŸ”„ [NAVIGATION] Progress: ${position.current_position}/${position.total_slides} slides`);
                }
            }
            
            setupSlideInteractionButtons() {
                // Cette fonction ne fait plus rien car les anciens boutons ont Ã©tÃ© supprimÃ©s
                // Tous les boutons sont maintenant gÃ©rÃ©s par setupNewNavigationButtons()
                console.log('âœ… [BUTTONS] setupSlideInteractionButtons - anciens boutons supprimÃ©s');
            }
            
            setupNewNavigationButtons() {
                // Connect new navigation buttons to same actions as old ones
                const newSimplifyBtn = document.getElementById('new-simplify-btn');
                const newMoreDetailsBtn = document.getElementById('new-more-details-btn');
                const newNextBtn = document.getElementById('new-next-btn');
                const newPreviousBtn = document.getElementById('new-previous-btn');
                
                if (newSimplifyBtn) {
                    newSimplifyBtn.addEventListener('click', () => this.simplifySlideContent());
                    console.log('âœ… [NEW_BUTTONS] New simplify button connected');
                }
                
                if (newMoreDetailsBtn) {
                    newMoreDetailsBtn.addEventListener('click', () => this.moreDetailsSlideContent());
                    console.log('âœ… [NEW_BUTTONS] New more details button connected');
                }
                
                if (newNextBtn) {
                    newNextBtn.addEventListener('click', () => this.navigateToNextSlide());
                    console.log('âœ… [NEW_BUTTONS] New next button connected');
                }
                
                if (newPreviousBtn) {
                    newPreviousBtn.addEventListener('click', () => this.navigateToPreviousSlide());
                    console.log('âœ… [NEW_BUTTONS] New previous button connected');
                }
            }
            
            async simplifySlideContent() {
                const newSimplifyBtn = document.getElementById('new-simplify-btn');
                const slideContentEl = document.getElementById('slide-content');
                
                if (!slideContentEl) {
                    console.error('âŒ [SIMPLIFY] Slide content element not found');
                    return;
                }
                
                try {
                    console.log('ğŸ¯ [SIMPLIFY] Starting slide content simplification');
                    
                    // DÃ©sactiver le bouton pendant le traitement
                    if (newSimplifyBtn) {
                        newSimplifyBtn.disabled = true;
                        newSimplifyBtn.innerHTML = '<i class="bi bi-hourglass-split me-1"></i>Simplifying...';
                    }
                    
                    // Obtenir le contenu markdown actuel
                    const currentMarkdown = this.getCurrentSlideMarkdown();
                    if (!currentMarkdown) {
                        console.error('âŒ [SIMPLIFY] No current slide content to simplify');
                        return;
                    }
                    
                    console.log('ğŸ“ [SIMPLIFY] Current content length:', currentMarkdown.length);
                    console.log('ğŸ“ [SIMPLIFY] Current content preview:', currentMarkdown.substring(0, 100) + '...');
                    
                    // Appeler l'API de simplification
                    const response = await fetch(`/api/slides/simplify/${this.learnerSession.id}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            current_content: currentMarkdown
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`API request failed: ${response.status} ${response.statusText}`);
                    }
                    
                    const result = await response.json();
                    console.log('âœ… [SIMPLIFY] API response received:', result);
                    
                    if (result.success && result.data.simplified_content) {
                        // Remplacer le contenu de la slide avec la version simplifiÃ©e
                        const simplifiedContent = result.data.simplified_content;
                        console.log('ğŸ“ [SIMPLIFY] Simplified content length:', simplifiedContent.length);
                        console.log('ğŸ“ [SIMPLIFY] Simplified content preview:', simplifiedContent.substring(0, 100) + '...');
                        
                        // Mettre Ã  jour l'affichage
                        slideContentEl.innerHTML = this.markdownToHtml(simplifiedContent);
                        
                        // Sauvegarder le nouveau contenu pour usage futur
                        this.currentSlideContent = simplifiedContent;
                        
                        console.log('âœ… [SIMPLIFY] Slide content simplified successfully');
                        
                        // Afficher un message de succÃ¨s temporaire
                        this.showSimplifySuccess(result.data);
                        
                    } else {
                        throw new Error('Invalid API response structure');
                    }
                    
                } catch (error) {
                    console.error('âŒ [SIMPLIFY] Error simplifying slide content:', error);
                    
                    // Afficher une erreur Ã  l'utilisateur
                    this.showSimplifyError(error.message);
                    
                } finally {
                    // RÃ©activer le bouton
                    if (newSimplifyBtn) {
                        newSimplifyBtn.disabled = false;
                        newSimplifyBtn.innerHTML = '<i class="bi bi-arrow-down-circle me-1"></i>Simplify';
                    }
                }
            }
            
            getCurrentSlideMarkdown() {
                // Pour l'instant, nous devons reconstruire le markdown Ã  partir du HTML affichÃ©
                // Dans une implÃ©mentation future, nous pourrions stocker le markdown original
                return this.currentSlideContent || 'No slide content available';
            }
            
            showSimplifySuccess(data) {
                // Alerts supprimÃ©s - fonction dÃ©sactivÃ©e
                console.log('ğŸ¯ [SIMPLIFY] Content simplified successfully:', data);
            }
            
            showSimplifyError(errorMessage) {
                // Alerts supprimÃ©s - fonction dÃ©sactivÃ©e
                console.error('âŒ [SIMPLIFY] Error:', errorMessage);
            }
            
            async moreDetailsSlideContent() {
                const newMoreDetailsBtn = document.getElementById('new-more-details-btn');
                const slideContentEl = document.getElementById('slide-content');
                
                if (!slideContentEl) {
                    console.error('âŒ [MORE_DETAILS] Slide content element not found');
                    return;
                }
                
                try {
                    console.log('ğŸ¯ [MORE_DETAILS] Starting slide content enhancement');
                    
                    // DÃ©sactiver le bouton pendant le traitement
                    if (newMoreDetailsBtn) {
                        newMoreDetailsBtn.disabled = true;
                        newMoreDetailsBtn.innerHTML = '<i class="bi bi-hourglass-split me-1"></i>Adding Details...';
                    }
                    
                    // Obtenir le contenu markdown actuel
                    const currentMarkdown = this.getCurrentSlideMarkdown();
                    if (!currentMarkdown) {
                        console.error('âŒ [MORE_DETAILS] No current slide content to enhance');
                        return;
                    }
                    
                    console.log('ğŸ“ [MORE_DETAILS] Current content length:', currentMarkdown.length);
                    console.log('ğŸ“ [MORE_DETAILS] Current content preview:', currentMarkdown.substring(0, 100) + '...');
                    
                    // Appeler l'API d'approfondissement
                    const response = await fetch(`/api/slides/more-details/${this.learnerSession.id}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            current_content: currentMarkdown
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`API request failed: ${response.status} ${response.statusText}`);
                    }
                    
                    const result = await response.json();
                    console.log('âœ… [MORE_DETAILS] API response received:', result);
                    
                    if (result.success && result.data.detailed_content) {
                        // Remplacer le contenu de la slide avec la version approfondie
                        const detailedContent = result.data.detailed_content;
                        console.log('ğŸ“ [MORE_DETAILS] Enhanced content length:', detailedContent.length);
                        console.log('ğŸ“ [MORE_DETAILS] Enhanced content preview:', detailedContent.substring(0, 100) + '...');
                        
                        // Mettre Ã  jour l'affichage
                        slideContentEl.innerHTML = this.markdownToHtml(detailedContent);
                        
                        // Sauvegarder le nouveau contenu pour usage futur
                        this.currentSlideContent = detailedContent;
                        
                        console.log('âœ… [MORE_DETAILS] Slide content enhanced successfully');
                        
                        // Afficher un message de succÃ¨s temporaire
                        this.showMoreDetailsSuccess(result.data);
                        
                    } else {
                        throw new Error('Invalid API response structure');
                    }
                    
                } catch (error) {
                    console.error('âŒ [MORE_DETAILS] Error enhancing slide content:', error);
                    
                    // Afficher une erreur Ã  l'utilisateur
                    this.showMoreDetailsError(error.message);
                    
                } finally {
                    // RÃ©activer le bouton
                    if (newMoreDetailsBtn) {
                        newMoreDetailsBtn.disabled = false;
                        newMoreDetailsBtn.innerHTML = '<i class="bi bi-arrow-up-circle me-1"></i>Deepen';
                    }
                }
            }
            
            showMoreDetailsSuccess(data) {
                // Alerts supprimÃ©s - fonction dÃ©sactivÃ©e
                console.log('ğŸ¯ [MORE_DETAILS] Content enhanced successfully:', data);
            }
            
            showMoreDetailsError(errorMessage) {
                // Alerts supprimÃ©s - fonction dÃ©sactivÃ©e
                console.error('âŒ [MORE_DETAILS] Error:', errorMessage);
            }
            
            async navigateToNextSlide() {
                const newNextBtn = document.getElementById('new-next-btn');
                
                if (!this.currentSlide) {
                    console.error('âŒ [NAVIGATION] No current slide data available');
                    this.showNavigationError('No current slide information available');
                    return;
                }
                
                try {
                    console.log('ğŸ¯ [NAVIGATION] Starting navigation to next slide');
                    
                    // DÃ©sactiver le bouton pendant le traitement
                    if (newNextBtn) {
                        newNextBtn.disabled = true;
                        newNextBtn.innerHTML = '<i class="bi bi-hourglass-split me-1"></i>Loading...';
                    }
                    
                    // Obtenir l'ID de la slide actuelle
                    const currentSlideId = this.currentSlide.slide_id || this.currentSlide.id;
                    if (!currentSlideId) {
                        console.error('âŒ [NAVIGATION] No current slide ID found');
                        this.showNavigationError('Could not determine current slide');
                        return;
                    }
                    
                    console.log('ğŸ“ [NAVIGATION] Current slide ID:', currentSlideId);
                    console.log('ğŸ“ [NAVIGATION] Learner session ID:', this.learnerSession.id);
                    
                    // Appeler l'API de navigation
                    const response = await fetch(`/api/slides/next/${this.learnerSession.id}/${currentSlideId}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    console.log('ğŸ“¥ [NAVIGATION] Response status:', response.status);
                    
                    if (!response.ok) {
                        const errorData = await response.json();
                        console.error('âŒ [NAVIGATION] Error response:', errorData);
                        
                        // Check if we've reached the end
                        if (response.status === 404 || errorData.message?.includes('end')) {
                            this.showNavigationComplete();
                            return;
                        }
                        
                        throw new Error(errorData.detail || 'Failed to navigate to next slide');
                    }
                    
                    const navigationResult = await response.json();
                    console.log('âœ… [NAVIGATION] Success response:', navigationResult);
                    
                    // Check if there's no next slide
                    if (!navigationResult.success || !navigationResult.data.has_next) {
                        this.showNavigationComplete();
                        return;
                    }
                    
                    // Display the next slide
                    this.displaySlideContent(navigationResult.data);
                    this.showNavigationSuccess(navigationResult.data);
                    
                } catch (error) {
                    console.error('âŒ [NAVIGATION] Error:', error);
                    this.showNavigationError(error.message);
                    
                } finally {
                    // RÃ©activer le bouton
                    if (newNextBtn) {
                        newNextBtn.disabled = false;
                        newNextBtn.innerHTML = 'Next<i class="bi bi-chevron-right ms-1"></i>';
                    }
                }
            }
            
            showNavigationSuccess(slideData) {
                // Alerts supprimÃ©s - fonction dÃ©sactivÃ©e
                console.log('ğŸ¯ [NAVIGATION] Navigation successful:', slideData.title || 'Next slide');
            }
            
            showNavigationComplete() {
                // Alerts supprimÃ©s - garde seulement la logique des boutons
                console.log('ğŸ¯ [NAVIGATION] Training complete!');
                
                // Disable the Next button
                const newNextBtn = document.getElementById('new-next-btn');
                if (newNextBtn) {
                    newNextBtn.disabled = true;
                    newNextBtn.innerHTML = '<i class="bi bi-check-circle me-1"></i>Complete';
                }
            }
            
            showNavigationError(errorMessage) {
                // Alerts supprimÃ©s - fonction dÃ©sactivÃ©e
                console.error('âŒ [NAVIGATION] Error:', errorMessage);
            }
            
            async navigateToPreviousSlide() {
                const newPreviousBtn = document.getElementById('new-previous-btn');
                
                if (!this.currentSlide) {
                    console.error('âŒ [NAVIGATION] No current slide data available');
                    this.showNavigationError('No current slide information available');
                    return;
                }
                
                try {
                    console.log('ğŸ¯ [NAVIGATION] Starting navigation to previous slide');
                    
                    // DÃ©sactiver le bouton pendant le traitement
                    if (newPreviousBtn) {
                        newPreviousBtn.disabled = true;
                        newPreviousBtn.innerHTML = '<i class="bi bi-hourglass-split me-1"></i>Loading...';
                    }
                    
                    // Obtenir l'ID de la slide actuelle
                    const currentSlideId = this.currentSlide.slide_id || this.currentSlide.id;
                    if (!currentSlideId) {
                        console.error('âŒ [NAVIGATION] No current slide ID found');
                        this.showNavigationError('Could not determine current slide');
                        return;
                    }
                    
                    console.log('ğŸ“ [NAVIGATION] Current slide ID:', currentSlideId);
                    console.log('ğŸ“ [NAVIGATION] Learner session ID:', this.learnerSession.id);
                    
                    // Appeler l'API de navigation prÃ©cÃ©dente
                    const response = await fetch(`/api/slides/previous/${this.learnerSession.id}/${currentSlideId}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    console.log('ğŸ“¥ [NAVIGATION] Response status:', response.status);
                    
                    if (!response.ok) {
                        const errorData = await response.json();
                        console.error('âŒ [NAVIGATION] Error response:', errorData);
                        
                        // Check if we've reached the beginning
                        if (response.status === 404 || errorData.message?.includes('beginning')) {
                            this.showNavigationBeginning();
                            return;
                        }
                        
                        throw new Error(errorData.detail || 'Failed to navigate to previous slide');
                    }
                    
                    const navigationResult = await response.json();
                    console.log('âœ… [NAVIGATION] Success response:', navigationResult);
                    
                    // Check if there's no previous slide
                    if (!navigationResult.success || !navigationResult.data.has_previous) {
                        this.showNavigationBeginning();
                        return;
                    }
                    
                    // Display the previous slide
                    this.displaySlideContent(navigationResult.data);
                    this.showPreviousNavigationSuccess(navigationResult.data);
                    
                } catch (error) {
                    console.error('âŒ [NAVIGATION] Error:', error);
                    this.showNavigationError(error.message);
                    
                } finally {
                    // RÃ©activer le bouton
                    if (newPreviousBtn) {
                        newPreviousBtn.disabled = false;
                        newPreviousBtn.innerHTML = '<i class="bi bi-chevron-left me-1"></i>Previous';
                    }
                }
            }
            
            showPreviousNavigationSuccess(slideData) {
                // Alerts supprimÃ©s - fonction dÃ©sactivÃ©e
                console.log('ğŸ¯ [NAVIGATION] Previous navigation successful:', slideData.title || 'Previous slide');
            }
            
            showNavigationBeginning() {
                // Alerts supprimÃ©s - garde seulement la logique des boutons
                console.log('ğŸ¯ [NAVIGATION] At the beginning!');
                
                // Disable the Previous button
                const newPreviousBtn = document.getElementById('new-previous-btn');
                if (newPreviousBtn) {
                    newPreviousBtn.disabled = true;
                    newPreviousBtn.innerHTML = '<i class="bi bi-stop-circle me-1"></i>Beginning';
                }
                
                // RÃ©activer le bouton aprÃ¨s 5 secondes
                setTimeout(() => {
                    if (newPreviousBtn && this.currentSlide && (this.currentSlide.position?.has_previous !== false)) {
                        newPreviousBtn.disabled = false;
                        newPreviousBtn.innerHTML = '<i class="bi bi-chevron-left me-1"></i>Previous';
                    }
                }, 5000);
            }
            
            // ============================================================================
            // LIVE VOICE FUNCTIONALITY
            // ============================================================================
            
            setupLiveVoiceFunctionality() {
                const liveVoiceBtn = document.getElementById('live-voice-btn');
                
                if (liveVoiceBtn) {
                    liveVoiceBtn.addEventListener('click', () => this.toggleLiveVoice());
                    console.log('âœ… [LIVE_VOICE] Live voice button event listener added');
                } else {
                    console.warn('âš ï¸ [LIVE_VOICE] Live voice button not found');
                }
                
                // Initialize Live Voice state
                this.liveVoiceState = {
                    isActive: false,
                    isConnecting: false,
                    websocket: null,
                    mediaRecorder: null,
                    audioContext: null,
                    microphone: null,
                    audioChunks: []
                };
            }
            
            async toggleLiveVoice() {
                console.log('ğŸ™ï¸ [LIVE_VOICE] Toggle live voice, current state:', this.liveVoiceState.isActive);
                
                if (this.liveVoiceState.isActive) {
                    await this.stopLiveVoice();
                } else {
                    await this.startLiveVoice();
                }
            }
            
            async startLiveVoice() {
                const liveBtn = document.getElementById('live-voice-btn');
                const liveIcon = document.getElementById('live-voice-icon');
                const liveText = document.getElementById('live-voice-text');
                const liveStatus = document.getElementById('live-status');
                
                try {
                    console.log('ğŸš€ [LIVE_VOICE] Starting live voice session...');
                    
                    // Update UI to connecting state
                    this.liveVoiceState.isConnecting = true;
                    if (liveBtn) liveBtn.disabled = true;
                    if (liveIcon) liveIcon.className = 'bi bi-hourglass-split me-1';
                    if (liveText) liveText.textContent = 'Connecting...';
                    if (liveStatus) liveStatus.textContent = 'Connecting to Live API...';
                    
                    // Request microphone access
                    console.log('ğŸ¤ [LIVE_VOICE] Requesting microphone access...');
                    
                    // Check if we're in a secure context for microphone access
                    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                        throw new Error('Microphone access not available. Please use HTTPS or localhost.');
                    }
                    
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            sampleRate: 16000,
                            channelCount: 1,
                            echoCancellation: true,
                            noiseSuppression: true
                        } 
                    });
                    
                    console.log('âœ… [LIVE_VOICE] Microphone access granted');
                    
                    // Initialize Audio Context
                    this.liveVoiceState.audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });
                    this.liveVoiceState.microphone = this.liveVoiceState.audioContext.createMediaStreamSource(stream);
                    
                    // Connect to WebSocket
                    await this.connectLiveWebSocket();
                    
                    // Setup MediaRecorder for audio capture
                    this.setupAudioRecording(stream);
                    
                    // Update state
                    this.liveVoiceState.isActive = true;
                    this.liveVoiceState.isConnecting = false;
                    
                    // Update UI to active state
                    if (liveBtn) {
                        liveBtn.disabled = false;
                        liveBtn.className = 'btn btn-success w-100 btn-sm';
                    }
                    if (liveIcon) liveIcon.className = 'bi bi-mic-fill me-1';
                    if (liveText) liveText.textContent = 'Live Voice Active';
                    if (liveStatus) liveStatus.textContent = 'Speak now - AI is listening';
                    
                    console.log('âœ… [LIVE_VOICE] Live voice session started successfully');
                    
                } catch (error) {
                    console.error('âŒ [LIVE_VOICE] Error starting live voice:', error);
                    
                    // Reset state
                    this.liveVoiceState.isConnecting = false;
                    this.liveVoiceState.isActive = false;
                    
                    // Reset UI
                    if (liveBtn) {
                        liveBtn.disabled = false;
                        liveBtn.className = 'btn btn-danger w-100 btn-sm';
                    }
                    if (liveIcon) liveIcon.className = 'bi bi-mic me-1';
                    if (liveText) liveText.textContent = 'Start Live Voice';
                    if (liveStatus) liveStatus.textContent = `Error: ${error.message}`;
                    
                    // Show error in chat
                    this.addChatMessage('assistant', 
                        `I couldn't start the live voice session. Error: ${error.message}. Please check your microphone permissions and try again.`,
                        { error: true }
                    );
                }
            }
            
            async connectLiveWebSocket() {
                return new Promise((resolve, reject) => {
                    console.log('ğŸ”— [LIVE_VOICE] Connecting to WebSocket...');
                    
                    // Pour localhost, utiliser toujours ws:// mÃªme si la page est en http://
                    const wsProtocol = (window.location.protocol === 'https:' && !window.location.hostname.includes('localhost')) ? 'wss:' : 'ws:';
                    const wsUrl = `${wsProtocol}//${window.location.host}/ws/live/${this.learnerSession.id}`;
                    
                    console.log('ğŸ”— [LIVE_VOICE] Protocol detection:', {
                        'window.location.protocol': window.location.protocol,
                        'window.location.hostname': window.location.hostname,
                        'wsProtocol': wsProtocol,
                        'wsUrl': wsUrl
                    });
                    
                    console.log('ğŸ”— [LIVE_VOICE] WebSocket URL:', wsUrl);
                    
                    this.liveVoiceState.websocket = new WebSocket(wsUrl);
                    
                    this.liveVoiceState.websocket.onopen = (event) => {
                        console.log('âœ… [LIVE_VOICE] WebSocket connected');
                        resolve();
                    };
                    
                    this.liveVoiceState.websocket.onmessage = (event) => {
                        this.handleLiveWebSocketMessage(event);
                    };
                    
                    this.liveVoiceState.websocket.onerror = (error) => {
                        console.error('âŒ [LIVE_VOICE] WebSocket error:', error);
                        reject(new Error('WebSocket connection failed'));
                    };
                    
                    this.liveVoiceState.websocket.onclose = (event) => {
                        console.log('ğŸ”Œ [LIVE_VOICE] WebSocket closed:', event.code, event.reason);
                        if (this.liveVoiceState.isActive) {
                            this.handleLiveDisconnection();
                        }
                    };
                });
            }
            
            setupAudioRecording(stream) {
                console.log('ğŸµ [LIVE_VOICE] Setting up audio recording...');
                
                // Create MediaRecorder with best supported format
                let options = { mimeType: 'audio/webm;codecs=opus' };
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    options = { mimeType: 'audio/ogg;codecs=opus' };
                    if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                        options = { mimeType: 'audio/webm' };
                        if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                            options = {}; // Use default
                        }
                    }
                }
                
                console.log('ğŸµ [LIVE_VOICE] Using MediaRecorder format:', options.mimeType || 'default');
                this.liveVoiceState.mediaRecorder = new MediaRecorder(stream, options);
                this.liveVoiceState.currentMimeType = options.mimeType || 'audio/webm';
                
                this.liveVoiceState.audioChunks = [];
                
                this.liveVoiceState.mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        console.log('ğŸµ [LIVE_VOICE] Audio chunk received:', event.data.size, 'bytes');
                        this.liveVoiceState.audioChunks.push(event.data);
                        this.processAudioChunk(event.data);
                    }
                };
                
                this.liveVoiceState.mediaRecorder.onstop = () => {
                    console.log('ğŸµ [LIVE_VOICE] MediaRecorder stopped');
                };
                
                // Start recording in chunks (send every 1 second)
                this.liveVoiceState.mediaRecorder.start(1000);
                console.log('âœ… [LIVE_VOICE] Audio recording started');
            }
            
            async processAudioChunk(audioBlob) {
                try {
                    console.log('ğŸµ [LIVE_VOICE] Processing audio chunk:', audioBlob.size, 'bytes');
                    
                    // Convert blob to ArrayBuffer
                    const arrayBuffer = await audioBlob.arrayBuffer();
                    const base64Audio = this.arrayBufferToBase64(arrayBuffer);
                    
                    // Send audio via WebSocket
                    if (this.liveVoiceState.websocket && this.liveVoiceState.websocket.readyState === WebSocket.OPEN) {
                        const message = {
                            type: 'audio',
                            data: base64Audio,
                            mime_type: this.liveVoiceState.currentMimeType || 'audio/webm'
                        };
                        
                        this.liveVoiceState.websocket.send(JSON.stringify(message));
                        console.log('ğŸ“¤ [LIVE_VOICE] Audio chunk sent via WebSocket');
                    } else {
                        console.warn('âš ï¸ [LIVE_VOICE] WebSocket not ready, skipping audio chunk');
                    }
                    
                } catch (error) {
                    console.error('âŒ [LIVE_VOICE] Error processing audio chunk:', error);
                }
            }
            
            arrayBufferToBase64(buffer) {
                const bytes = new Uint8Array(buffer);
                let binary = '';
                for (let i = 0; i < bytes.byteLength; i++) {
                    binary += String.fromCharCode(bytes[i]);
                }
                return btoa(binary);
            }
            
            base64ToArrayBuffer(base64) {
                const binaryString = atob(base64);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return bytes.buffer;
            }
            
            handleLiveWebSocketMessage(event) {
                try {
                    const message = JSON.parse(event.data);
                    console.log('ğŸ“¥ [LIVE_VOICE] WebSocket message received:', message.type);
                    
                    switch (message.type) {
                        case 'session_started':
                            console.log('âœ… [LIVE_VOICE] Live session started:', message.live_session_id);
                            this.addChatMessage('assistant', 
                                'Live voice session started! I can now hear you speaking.',
                                { action_type: 'live-session' }
                            );
                            break;
                            
                        case 'audio_response':
                            console.log('ğŸ”Š [LIVE_VOICE] Audio response received');
                            // Only process if we have actual content or if not throttled
                            if (message.metadata && message.metadata.throttled) {
                                console.log('â¸ï¸ [LIVE_VOICE] Response throttled, skipping...');
                                break;
                            }
                            
                            // Check for text-only mode (mock responses)
                            const isTextOnly = message.metadata && message.metadata.text_only;
                            const hasText = message.metadata && message.metadata.text_transcript;
                            const hasAudio = message.data && message.data.length > 0;
                            
                            if (isTextOnly && hasText) {
                                console.log('ğŸ“ [LIVE_VOICE] Text-only response received (mock mode)');
                                this.addChatMessage('assistant', 
                                    message.metadata.text_transcript,
                                    { action_type: 'live-voice', mock: true }
                                );
                            } else if (hasAudio || hasText) {
                                this.playAudioResponse(message.data, message.metadata);
                            } else {
                                console.log('ğŸ”‡ [LIVE_VOICE] Empty response, skipping...');
                            }
                            break;
                            
                        case 'error':
                            console.error('âŒ [LIVE_VOICE] WebSocket error:', message.message);
                            this.addChatMessage('assistant', 
                                `Live voice error: ${message.message}`,
                                { error: true }
                            );
                            break;
                            
                        case 'pong':
                            console.log('ğŸ“ [LIVE_VOICE] Pong received');
                            break;
                            
                        default:
                            console.log('â“ [LIVE_VOICE] Unknown message type:', message.type);
                    }
                    
                } catch (error) {
                    console.error('âŒ [LIVE_VOICE] Error parsing WebSocket message:', error);
                }
            }
            
            async playAudioResponse(base64Audio, metadata) {
                try {
                    console.log('ğŸ”Š [LIVE_VOICE] Playing audio response...');
                    console.log('ğŸ”Š [LIVE_VOICE] Audio data length:', base64Audio ? base64Audio.length : 'null');
                    console.log('ğŸ”Š [LIVE_VOICE] Metadata:', metadata);
                    
                    // Check if this is mock mode
                    const isMockMode = metadata && metadata.processing_metadata && metadata.processing_metadata.mock === true;
                    
                    if (isMockMode) {
                        console.log('ğŸ­ [LIVE_VOICE] Mock mode detected - skipping audio playback');
                        
                        // In mock mode, just show the text transcript
                        if (metadata && metadata.text_transcript) {
                            this.addChatMessage('assistant', 
                                metadata.text_transcript,
                                { action_type: 'live-voice', mock: true }
                            );
                        }
                        
                        // Play a simple confirmation sound instead of trying to decode mock audio
                        this.playMockAudioConfirmation();
                        return;
                    }
                    
                    // Check if we have valid audio data
                    if (!base64Audio || base64Audio.length === 0) {
                        console.warn('âš ï¸ [LIVE_VOICE] No audio data received');
                        // If we have text and it's mock mode, show it normally (not as error)
                        if (metadata && metadata.text_transcript) {
                            const isTextOnlyMode = metadata.text_only || metadata.mock;
                            if (isTextOnlyMode) {
                                this.addChatMessage('assistant', 
                                    metadata.text_transcript,
                                    { action_type: 'live-voice', mock: true }
                                );
                            } else {
                                this.addChatMessage('assistant', 
                                    `[No audio data] ${metadata.text_transcript}`,
                                    { error: true }
                                );
                            }
                        }
                        return;
                    }
                    
                    // Real audio mode - try to decode and play actual audio
                    const audioBuffer = this.base64ToArrayBuffer(base64Audio);
                    
                    // Create audio context if needed
                    if (!this.liveVoiceState.audioContext) {
                        this.liveVoiceState.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    
                    // Try to decode and play audio with fallback
                    try {
                        const decodedAudio = await this.liveVoiceState.audioContext.decodeAudioData(audioBuffer.slice(0));
                        const source = this.liveVoiceState.audioContext.createBufferSource();
                        source.buffer = decodedAudio;
                        source.connect(this.liveVoiceState.audioContext.destination);
                        source.start();
                        
                        console.log('âœ… [LIVE_VOICE] Audio response playing');
                    } catch (decodeError) {
                        console.warn('âš ï¸ [LIVE_VOICE] WebAudio decode failed, trying HTML5 audio:', decodeError);
                        
                        // Fallback to HTML5 Audio
                        const audioBlob = new Blob([audioBuffer], { type: 'audio/ogg' });
                        const audioUrl = URL.createObjectURL(audioBlob);
                        const audio = new Audio(audioUrl);
                        
                        audio.onended = () => URL.revokeObjectURL(audioUrl);
                        audio.onerror = (audioError) => {
                            console.error('âŒ [LIVE_VOICE] HTML5 audio also failed:', audioError);
                            // Don't throw error, just fallback to text
                            console.log('ğŸ”„ [LIVE_VOICE] Falling back to text-only response');
                        };
                        
                        await audio.play();
                        console.log('âœ… [LIVE_VOICE] HTML5 audio playing');
                    }
                    
                    // Add transcript to chat if available
                    if (metadata && metadata.text_transcript) {
                        this.addChatMessage('assistant', 
                            metadata.text_transcript,
                            { action_type: 'live-voice' }
                        );
                    }
                    
                } catch (error) {
                    console.error('âŒ [LIVE_VOICE] Error playing audio response:', error);
                    
                    // Fallback: show text response if audio fails
                    if (metadata && metadata.text_transcript) {
                        this.addChatMessage('assistant', 
                            metadata.text_transcript, // Remove error prefix since it's expected
                            { action_type: 'live-voice' }
                        );
                    } else {
                        this.addChatMessage('assistant', 
                            'Audio response received but could not be played.',
                            { action_type: 'live-voice' }
                        );
                    }
                }
            }
            
            playMockAudioConfirmation() {
                try {
                    console.log('ğŸ­ [LIVE_VOICE] Playing mock audio confirmation beep');
                    
                    // Create audio context if needed
                    if (!this.liveVoiceState.audioContext) {
                        this.liveVoiceState.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    
                    // Generate a simple confirmation beep (1000Hz for 200ms)
                    const audioCtx = this.liveVoiceState.audioContext;
                    const oscillator = audioCtx.createOscillator();
                    const gainNode = audioCtx.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioCtx.destination);
                    
                    oscillator.frequency.value = 1000; // 1kHz beep
                    gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime); // Low volume
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.2); // Fade out
                    
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.2); // 200ms beep
                    
                    console.log('âœ… [LIVE_VOICE] Mock confirmation beep played');
                    
                } catch (error) {
                    console.warn('âš ï¸ [LIVE_VOICE] Could not play mock confirmation beep:', error);
                    // Not a critical error, continue silently
                }
            }
            
            async stopLiveVoice() {
                console.log('ğŸ›‘ [LIVE_VOICE] Stopping live voice session...');
                
                const liveBtn = document.getElementById('live-voice-btn');
                const liveIcon = document.getElementById('live-voice-icon');
                const liveText = document.getElementById('live-voice-text');
                const liveStatus = document.getElementById('live-status');
                
                try {
                    // Stop MediaRecorder
                    if (this.liveVoiceState.mediaRecorder && this.liveVoiceState.mediaRecorder.state !== 'inactive') {
                        this.liveVoiceState.mediaRecorder.stop();
                    }
                    
                    // Close WebSocket
                    if (this.liveVoiceState.websocket) {
                        this.liveVoiceState.websocket.send(JSON.stringify({ type: 'close' }));
                        this.liveVoiceState.websocket.close();
                        this.liveVoiceState.websocket = null;
                    }
                    
                    // Stop microphone
                    if (this.liveVoiceState.microphone && this.liveVoiceState.microphone.mediaStream) {
                        this.liveVoiceState.microphone.mediaStream.getTracks().forEach(track => track.stop());
                    }
                    
                    // Close audio context
                    if (this.liveVoiceState.audioContext) {
                        await this.liveVoiceState.audioContext.close();
                        this.liveVoiceState.audioContext = null;
                    }
                    
                    // Reset state
                    this.liveVoiceState.isActive = false;
                    this.liveVoiceState.isConnecting = false;
                    this.liveVoiceState.mediaRecorder = null;
                    this.liveVoiceState.microphone = null;
                    this.liveVoiceState.audioChunks = [];
                    
                    // Reset UI
                    if (liveBtn) {
                        liveBtn.disabled = false;
                        liveBtn.className = 'btn btn-danger w-100 btn-sm';
                    }
                    if (liveIcon) liveIcon.className = 'bi bi-mic me-1';
                    if (liveText) liveText.textContent = 'Start Live Voice';
                    if (liveStatus) liveStatus.textContent = 'Click to talk with AI trainer';
                    
                    console.log('âœ… [LIVE_VOICE] Live voice session stopped successfully');
                    
                    this.addChatMessage('assistant', 
                        'Live voice session ended. Click the Live Voice button to start a new session.',
                        { action_type: 'live-session' }
                    );
                    
                } catch (error) {
                    console.error('âŒ [LIVE_VOICE] Error stopping live voice:', error);
                }
            }
            
            handleLiveDisconnection() {
                console.log('ğŸ”Œ [LIVE_VOICE] Handling live disconnection...');
                
                // Force stop live voice
                this.stopLiveVoice();
                
                this.addChatMessage('assistant', 
                    'Live voice session was disconnected unexpectedly. You can start a new session anytime.',
                    { error: true }
                );
            }
            
            showError(message) {
                this.container.innerHTML = `
                    <div class="row">
                        <div class="col-12">
                            <div class="alert alert-danger" role="alert">
                                <h4 class="alert-heading">
                                    <i class="bi bi-exclamation-triangle me-2"></i>Error
                                </h4>
                                <p>${message}</p>
                                <hr>
                                <div class="mb-0">
                                    <button class="btn btn-outline-danger" onclick="location.reload()">
                                        <i class="bi bi-arrow-clockwise me-1"></i>Retry
                                    </button>
                                    <button class="btn btn-outline-secondary" onclick="history.back()">
                                        <i class="bi bi-arrow-left me-1"></i>Go Back
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }
        }
        
        // Initialize the application when page loads
        document.addEventListener('DOMContentLoaded', () => {
            console.log('ğŸŒŸ Training page loaded, initializing app...');
            new TrainingApp();
        });
    </script>
</body>
</html>